/*
 Navicat Premium Data Transfer

 Source Server         : localhost_3306
 Source Server Type    : MySQL
 Source Server Version : 50022
 Source Host           : localhost:3306
 Source Schema         : db_news

 Target Server Type    : MySQL
 Target Server Version : 50022
 File Encoding         : 65001

 Date: 15/05/2018 12:37:05
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for news
-- ----------------------------
DROP TABLE IF EXISTS `news`;
CREATE TABLE `news`  (
  `newsId` int(11) NOT NULL AUTO_INCREMENT,
  `classId` int(11) NOT NULL DEFAULT '',
  `headTitle` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `content` mediumtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `author` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '',
  `editor` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `newsFrom` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `top` int(11) NULL DEFAULT NULL,
  `newsTime` datetime NULL DEFAULT NULL,
  `hits` int(11) NULL DEFAULT 0,
  `state` varchar(11) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `pictures` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `isDel` int(11) NULL DEFAULT NULL,
  PRIMARY KEY USING BTREE (`newsId`),
  INDEX `classId` USING BTREE(`classId`)
) ENGINE = MyISAM AUTO_INCREMENT = 128 CHARACTER SET = gb2312 COLLATE = gb2312_chinese_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of news
-- ----------------------------
INSERT INTO `news` VALUES (28, 1, '详解Linux回击微软', '据国外媒体报道，一直以来，微软都声称自己占有93%的全球上网本操作系统市场份额。然而，日前，ABI Research发布的数据却显示，Linux占据上网本市场32%的市场份额，并且还预测Linux将会在2013年的上网本市场中取代Windows。上述事实表明，两者的数据是大相径庭的。<br><br><br>公信力<br><br>　　毋庸置疑的，做为全球最大的软件公司，微软具有很强的公信力。<br><br><br>　　而ABI Research则已经从事调查行业19年的时间了，去年，高级分析师Jeff Orr也加入了ABI Research，可以说，ABI Research是一家根基稳固的公司。<br><br><br>戴尔发表声明<br><br>　　1月份，当有消息称，在上网本市场中，Windows彻底击败了Linux的时候，戴尔公司表示，该公司有1/3的Mini 9s预装的都是Linux，而且回报率并不比Windows XP。<br><br><br>　　分析师Orr强调指出，目前，很多的Linux用户都不是美国地区的，很多美国地区以外的用户使用的是Linux操作系统。<br><br><br>孰真孰假<br><br>　　众所周知，微软的首席执行官史蒂夫鲍尔默很反对外来物品，例如苹果的iPhone手机。前段时间，鲍尔默声称，该公司已经占据移动市场60%的市场份额，但是事实上仅为14%。由此看来，鲍尔默很有可能是一个温暖、充满关怀的CEO，并不喜欢听坏消息。<br><br><br>为何坏消息就是好消息<br><br>　　“例外管理”（MBE）是一个流行的管理模式，就是指有人必须将坏消息告知于CEO。然后，CEO就会寻找解决问题的途径。因此，坏消息可能会变成好消息。<br><br><br>　　但是，在微软公司中，很少会有人将坏消息报告给CEO。然而，事实就是事实，是掩盖不了的。<br><br><br>不同角度去分析问题<br><br>　　就这个问题来讲，并不能说微软公司在撒谎，很有可能是他们分析的国家和领域不同。', 'zhang', '小王', '华军资讯', 0, '2009-12-16 10:22:58', 4, '已审核', 'bus1.jpg', 0);
INSERT INTO `news` VALUES (29, 1, '开源Android将干掉Windows Mobile五大原因', '新闻分析：微软的Windows Mobile操作系统可能是Android崛起最容易攻击的对象，在过去的一年中，Android的市场份额稳步上升，伴随摩托罗拉采用Android操作系统的Droid手机热卖，Android的发展趋势越来越被看好，这意味着Windows Mobile在推出其7.0版本前很可能被挤出移动设备领域，而微软此前曾透露Windows Mobile 7要等到明天某个时候才会发布。<br><br>　　自采用Android操作系统的摩托罗拉Droid从11月5日上市以来，很多媒体竞相将其与苹果的iPhone进行对比，运营商Verizon更是启动了一系列的咄咄逼人的广告强调Droid的某些功能，如同时运行多个应用程序 ?? 这正是iPhone目前缺少的功能。<br><br>　　但苹果可能不是Android影响最严重的公司，Google将目标锁定的也不是苹果，而是微软。微软目前最新的Windows Mobile操作系统是6.5版，下一个版本Windows Mobile 7要等到2010年某个时候才会发布，Android目前要狙击的目标就是Windows Mobile 6.5，与苹果和其它公司不一样，微软依靠它的操作系统和附加软件捆绑到众多手机厂商和运营商的设备中，进而占据了大部分移动操作系统市场，很长一段时间内都是微软的天下，现在终于看到一个强劲的对手上场了。<br><br>　　Android的市场份额正在快速上升<br><br>　　目前诺基亚使用最多的Symbian操作系统也被证明不是Android的对手，其市场份额从2008年10月的59%下跌到2009年10月27%，表面上看起来对于微软是个好消息，但实际上据AdMob 最近的调查数据显示，Windows Mobile的市场份额也下降了70%左右。<br><br>　　微软已经意识到了这个问题，早今年9月24日举行的创业投资峰会上，微软CEO史蒂夫鲍尔默承认公司搞砸了Windows Mobile，同时公开表示Windows Mobile 7已经开始启动，微软在10月6日发布了Windows Mobile 6.5，包括扩展了触摸等功能，但这应该是微软在发布Windows Mobile 7之前不得已的一个权宜之计。<br><br>　　理论上说Windows Mobile 6.5的发布应该阻止对微软移动市场份额的侵蚀，微软还打算用Windows Mobile 7与iPhone和黑莓展开一场恶斗，但现在又多出一个Android，据AdMob的数据显示，在过去的一年里，Android的市场份额至少翻了1000%。<br><br>　　这一增长势头势必会吸引更多制造商拥抱Android，之前微软曾宣布到2010年底，将会有13家手机厂商采用Windows Mobile 6.5，包括LG，HTC和Sony。Android也不示弱，Google移动平台高级主管Andy Rubin早先估计到本年年底将会有18-20种设备使用Android，包括摩托罗拉，戴尔，宏基，诺基亚等厂家都开始尝试Android。<br><br>　　Android将会是应用程序的世界<br><br>　　微软原本计划在10月启动的Windows Marketplace中内置600个应用程序，但最终却只有250个都不到，虽然这一数字在两个月后扩大到了接近800，目前约有1000家独立ISV注册开发移动应用程序。<br><br>　　相对于其它巨头的动作，移动应用程序可能成为Windows Mobile的致命一击，即使如此，除了苹果的App Store有8万个应用程序外，微软的800个应用程序也对RIM的BlackBerry App World(1000多个应用程序)和Palm的应用程序商店(350多个)造成了冲击。<br><br>　　所有这些竞争设备都集成了它们自己的操作系统，Google Android是一个开源例外，正是由于这个原因它总是被抨击，如果不是手机制造商有意回避操作系统，Android Marketplace应该已经有2000多个应用程序了，如果Android保持其增长势头，Android应用程序将会呈大面积爆发。如果真的那样，更多手机厂家不得不转向Android，将会进一步挤压Windows Mobile的市场份额。<br><br>　　缺乏其它操作系统竞争对手<br><br>　　10月21日，Symbian基金会宣布Symbian操作系统正式开源，该平台的微内核EKA2(Epco Kernel Architecture 2)比原计划提前了9个月发布，包括遵循Eclipse公共许可的SDK。<br><br>　　正如前文提到的，Symbian操作系统的市场份额在过去的一年里和Windows Mobile一样大幅下降，Symbian最终不得不选择和Android一样走开源道路，但在开源道路上Android显然早已驾轻就熟。<br><br>　　硬件配对<br><br>　　Google Android已经和摩托罗拉Droid和HTC Droid Eris搭档成功，之前曾有权威人士将它们作为iPhone杀手称呼。在摩托罗拉Droid上市的头一周，就卖出了25万部，但还是距iPhone 3GS上市第一周热销的1600万部的记录相差甚远，不过许多分析师认为Droid的表现让人印象深刻。<br><br>　　而Windows Mobile就缺乏这样热卖的设备了，最近倒是热传微软将和Verizon联手在2010年推出一款智能手机。但除非这款手机变成实物，否则谁也不能保证其成为事实，目前有关这个合作项目Pink的消息仍然被封锁，而Android在强大的广告攻势下，每一个星期都会增加人们的心理份额，如果谷歌赶在微软之前发布自有品牌的手机，那这个心理份额将会加速上升。<br><br>　　Windows Mobile 7仍然是个未知数<br><br>　　微软已经承诺Windows Mobile 7将会带来实质性的更新，如果这次升级再给公众留下失败的印象，微软在移动领域将会处于难以维持的弱势地位，这将会给Android足够的机会赢得智能手机用户的青睐。', 'Linux论坛', '小王', 'Linux论坛', 0, '2009-12-16 10:23:38', 3, '已审核', 'bus2.jpg', 0);
INSERT INTO `news` VALUES (30, 4, '甲骨文向MySQL用户、开发者和客户的十项承诺', '甲骨文/SUN交易案最新动向：甲骨文向MySQL用户、开发者、客户做出十项承诺。<br>　　<br>　　甲骨文公司与欧盟委员会就甲骨文SUN公司的交易案进行了建设性的讨论，并承诺将保持MySQL在数据库市场的竞争力。为了进一步获得欧盟的批准，甲骨文公司公开其十项承诺，内容如下：<br>　　<br>　　<br>　　1、保证存储引擎API持续可用性。<br>　　甲骨文保证并阶段性加强MySQL的可插拔存储引擎架构，让用户可以灵活选择从本地和第三方产品提供存储引擎。此保证意味着MySQL当前的使用政策有效，允许符合SUN文件的存储引擎供应商接入MySQL数据库。<br>　　<br>　　2、不主张承诺。<br>　　作为版权持有人，甲骨文将改变SUN的现行政策，同时不得声称或威胁任何人，存储引擎第三方供应商必须基于GPL发布的，因为他们已经实行了应用编程接口有效，作为MySQL的可插入式存储引擎架构的一部分。商业许可无需通过Oracle请求。甲骨文将复制此承诺到与SUN有商业许可关系的存储供应商的合同当中。<br>　　<br>　　3、许可证的承诺。<br>　　当他们目前MySQL的OEM协议终止后，甲骨文将提供这些存储供应商与SUN相同的许可条件，不超过2014年。甲骨文将复制此承诺到与SUN有商业许可关系的存储供应商的合同当中。<br>　　<br>　　4、承诺在今后加强MySQL基于GPL发布。<br>　　MySQL后续版本，包括版本6，均将通过GPL发布。甲骨文公司不会在没有发布社区加强版的同时发布一个新的企业加强版。甲骨文公司将继续把MySQL社区版的所有版本的源代码公开，将免费提供。<br>　　<br>　　5、支持并不是强制性的 。<br>　　MySQL.客户不会被要求从甲骨文获得支持服务作为购买商业许可的条件。<br>　　<br>　　6、 增加对MySQL的研发支出 。 <br>　　<br>　　甲骨文承诺提供可用于MySQL持续发展的适当资金（GPL的版本和商业版本）。 在未来3年，每年，甲骨文将在MySQL的研发上投入比SUN的最近财年（2400万美元）还要多，在交易完成之前。<br>　　<br>　　7、成立MySQL客户顾问委员会 。<br>　　不迟于6个月后的一周年之际，甲骨文将创建并资助一个客户咨询委员会，包括最终用户和嵌入式客户提供指导和反馈，作为MySQL的发展优先事项，以及其他MySQL客户的重要问题。<br>　　<br>　　8、成立MySQL存储引擎供应商咨询委员会 。<br>　　不迟于6个月后的一周年之际，甲骨文将创建并资助一个存储引擎供应商咨询委员会，提供指导和反馈，作为MySQL的发展优先事项，以及其他MySQL存储引擎供应商的重要问题。<br>　　<br>　　9、 &nbsp;MySQL参考手册 。 <br>　　对MySQL参考手册，甲骨文公司将继续保持更新和免费下载，质量保持与SUN所提供的一致。<br>　　<br>　　10、 &nbsp;客户支持服务将继续 。<br>　　甲骨文将确保付费的最终用户和嵌入式客户提供MySQL的支持服务，根据客户的喜好更新订阅。<br>　　<br>　　这些承诺在全球范围内，并持续到交易完成五周年', 'oschina', '小王', 'oschina', 0, '2009-12-16 10:24:53', 2, '已审核', 'bus3.jpg', 0);
INSERT INTO `news` VALUES (31, 4, '甲骨文回应欧盟质疑 承诺加强MySQL业务', '<p><span style=\"font-size: medium;\"><span style=\"font-family: Times New Roman;\">甲骨文周一承诺，将会继续加强MySQL业务，并进一步以开源方式发布更新，希望借此打消欧盟委员会对该公司收购Sun的顾虑。</span></span><br />\r\n<br />\r\n全球最大数据库厂商甲骨文今年早些时候斥资74亿美元收购了Sun，但欧盟委员会目前正在对该交易进行审查。Sun的主要业务是服务器和Java，该公司同时拥有开源数据库软件MySQL。<br />\r\n<br />\r\n欧盟委员会此前曾表示，由于存在竞争关系，因此甲骨文收购Sun后会对免费开源软件MySQL的发展不利。甲骨文则表示，MySQL去年在欧洲的营业收入仅为1700万欧元(约合2487万美元)，无论从收入规模还是从产品档次来看，MySQL都不会对甲骨文的大型企业数据库构成威胁。<br />\r\n<br />\r\n甲骨文周一共做出了10项承诺，包括对外公布使用MySQL所需的编程细节，另外，在第三方开发者使用这些细节信息与MySQL进行交互时，甲骨文会放弃相应的版权主张。</p>', '陈真', '小王', '网络', 0, '2009-12-16 10:25:23', 1, '已审核', 'bus4.jpg', 0);
INSERT INTO `news` VALUES (32, 1, '开源Android将干掉Windows Mobile五大原因', '新闻分析：微软的Windows Mobile操作系统可能是Android崛起最容易攻击的对象，在过去的一年中，Android的市场份额稳步上升，伴随摩托罗拉采用Android操作系统的Droid手机热卖，Android的发展趋势越来越被看好，这意味着Windows Mobile在推出其7.0版本前很可能被挤出移动设备领域，而微软此前曾透露Windows Mobile 7要等到明天某个时候才会发布。<br><br>　　自采用Android操作系统的摩托罗拉Droid从11月5日上市以来，很多媒体竞相将其与苹果的iPhone进行对比，运营商Verizon更是启动了一系列的咄咄逼人的广告强调Droid的某些功能，如同时运行多个应用程序 ?? 这正是iPhone目前缺少的功能。<br><br>　　但苹果可能不是Android影响最严重的公司，Google将目标锁定的也不是苹果，而是微软。微软目前最新的Windows Mobile操作系统是6.5版，下一个版本Windows Mobile 7要等到2010年某个时候才会发布，Android目前要狙击的目标就是Windows Mobile 6.5，与苹果和其它公司不一样，微软依靠它的操作系统和附加软件捆绑到众多手机厂商和运营商的设备中，进而占据了大部分移动操作系统市场，很长一段时间内都是微软的天下，现在终于看到一个强劲的对手上场了。<br><br>　　Android的市场份额正在快速上升<br><br>　　目前诺基亚使用最多的Symbian操作系统也被证明不是Android的对手，其市场份额从2008年10月的59%下跌到2009年10月27%，表面上看起来对于微软是个好消息，但实际上据AdMob 最近的调查数据显示，Windows Mobile的市场份额也下降了70%左右。<br><br>　　微软已经意识到了这个问题，早今年9月24日举行的创业投资峰会上，微软CEO史蒂夫鲍尔默承认公司搞砸了Windows Mobile，同时公开表示Windows Mobile 7已经开始启动，微软在10月6日发布了Windows Mobile 6.5，包括扩展了触摸等功能，但这应该是微软在发布Windows Mobile 7之前不得已的一个权宜之计。<br><br>　　理论上说Windows Mobile 6.5的发布应该阻止对微软移动市场份额的侵蚀，微软还打算用Windows Mobile 7与iPhone和黑莓展开一场恶斗，但现在又多出一个Android，据AdMob的数据显示，在过去的一年里，Android的市场份额至少翻了1000%。<br><br>　　这一增长势头势必会吸引更多制造商拥抱Android，之前微软曾宣布到2010年底，将会有13家手机厂商采用Windows Mobile 6.5，包括LG，HTC和Sony。Android也不示弱，Google移动平台高级主管Andy Rubin早先估计到本年年底将会有18-20种设备使用Android，包括摩托罗拉，戴尔，宏基，诺基亚等厂家都开始尝试Android。<br><br>　　Android将会是应用程序的世界<br><br>　　微软原本计划在10月启动的Windows Marketplace中内置600个应用程序，但最终却只有250个都不到，虽然这一数字在两个月后扩大到了接近800，目前约有1000家独立ISV注册开发移动应用程序。<br><br>　　相对于其它巨头的动作，移动应用程序可能成为Windows Mobile的致命一击，即使如此，除了苹果的App Store有8万个应用程序外，微软的800个应用程序也对RIM的BlackBerry App World(1000多个应用程序)和Palm的应用程序商店(350多个)造成了冲击。<br><br>　　所有这些竞争设备都集成了它们自己的操作系统，Google Android是一个开源例外，正是由于这个原因它总是被抨击，如果不是手机制造商有意回避操作系统，Android Marketplace应该已经有2000多个应用程序了，如果Android保持其增长势头，Android应用程序将会呈大面积爆发。如果真的那样，更多手机厂家不得不转向Android，将会进一步挤压Windows Mobile的市场份额。<br><br>　　缺乏其它操作系统竞争对手<br><br>　　10月21日，Symbian基金会宣布Symbian操作系统正式开源，该平台的微内核EKA2(Epco Kernel Architecture 2)比原计划提前了9个月发布，包括遵循Eclipse公共许可的SDK。<br><br>　　正如前文提到的，Symbian操作系统的市场份额在过去的一年里和Windows Mobile一样大幅下降，Symbian最终不得不选择和Android一样走开源道路，但在开源道路上Android显然早已驾轻就熟。<br><br>　　硬件配对<br><br>　　Google Android已经和摩托罗拉Droid和HTC Droid Eris搭档成功，之前曾有权威人士将它们作为iPhone杀手称呼。在摩托罗拉Droid上市的头一周，就卖出了25万部，但还是距iPhone 3GS上市第一周热销的1600万部的记录相差甚远，不过许多分析师认为Droid的表现让人印象深刻。<br><br>　　而Windows Mobile就缺乏这样热卖的设备了，最近倒是热传微软将和Verizon联手在2010年推出一款智能手机。但除非这款手机变成实物，否则谁也不能保证其成为事实，目前有关这个合作项目Pink的消息仍然被封锁，而Android在强大的广告攻势下，每一个星期都会增加人们的心理份额，如果谷歌赶在微软之前发布自有品牌的手机，那这个心理份额将会加速上升。<br><br>　　Windows Mobile 7仍然是个未知数<br><br>　　微软已经承诺Windows Mobile 7将会带来实质性的更新，如果这次升级再给公众留下失败的印象，微软在移动领域将会处于难以维持的弱势地位，这将会给Android足够的机会赢得智能手机用户的青睐。', 'Linux论坛', '大王', 'Linux论坛', 0, '2010-01-31 10:48:56', 1, '已审核', 'business1.jpg', 0);
INSERT INTO `news` VALUES (33, 4, 'Mysql查询优化', '<h2 id=\"articleHeader0\" style=\"margin: 20px 0px 10px; padding: 0px 0px 5px; font-family: Arial; font-weight: 500; line-height: 1.1; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(238, 238, 238);\"><span style=\"line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; color: rgb(255, 0, 0);\">从事前端开发的都知道,页面显示的数据一定要及时的呈现,否则会影响用户体现.那么导致页面加载数据慢或者显示滞后的原因又是什么呢?</span></span></h2>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">拿自己之前做项目经历给大家讲讲吧,之前做后台,当时的项目实时性都非常高,前端页面实时显示要求非常高 ,慢1秒显示都会导致用户的投诉,最后没办法,通过本地(磁盘)缓存跟数据表分割来解决这一问题.</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-weight: 700;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">原因分析</span></span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\"><span style=\"font-weight: 700;\">主要原因1:</span>&nbsp;后台<a href=\"http://lib.csdn.net/base/14\" class=\"replace_word\" title=\"MySQL知识库\" target=\"_blank\" style=\"color: rgb(223, 52, 52); text-decoration: none; font-weight: bold;\">数据库</a>中的数据过多,没做数据优化导致后台查询数据很慢</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\"><span style=\"font-weight: 700;\">次要原因2:</span>&nbsp;前端数据请求-解析-展示过程处理不当</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\"><span style=\"font-weight: 700;\">次要原因3:</span>&nbsp;网络问题所致</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-weight: 700;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">那么我们应该怎么做后台数据优化呢?</span></span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-weight: 700;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">解决问题</span></span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-weight: 700;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">这里总结了几种方案,如何提高数据库查询的速度,大家参考.</span></span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">1、缓存，在持久层或持久层之上做缓存</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">使用ehcache缓存,这个一般用于持久层的缓存，提供持久层、业务层的快速缓存，hibenate默认使用的二级缓存就是ehcache;</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">2、数据库表的大字段剥离</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">假如一个表的字段数有100多个,学会拆分字段,保证单条记录的数据量很小;</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">3、恰当地使用索引</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">必要时建立多级索引,分析<a href=\"http://lib.csdn.net/base/14\" class=\"replace_word\" title=\"MySQL知识库\" target=\"_blank\" style=\"color: rgb(223, 52, 52); text-decoration: none; font-weight: bold;\">MySQL</a>的执行计划，通过表数据统计等方式协助数据库走正确的查询方式，该走索引就走索引，该走全表扫描就走全表扫描;</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">4、表的拆分</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">表分区和拆分，无论是业务逻辑上的拆分（如一个月一张报表、分库）还是无业务含义的分区（如根据ID取模分区）;</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">5、字段冗余</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">减少跨库查询和大表连接操作;,数据通过单个或多个JOB生成出来，减少实时查询;</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">6、从磁盘上做文章</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">数据存放的在磁盘的内、外磁道上，数据获取的效率都是不一样的;</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">7、放弃关系数据库的某些特性</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">引入NoSQL数据库;</span></p>\r\n<p style=\"margin: 0px 0px 25px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 28.8px;\"><span style=\"font-family: \'Courier New\'; font-size: 18px; color: rgb(255, 0, 0);\">换种思路存放数据，例如搜索中的倒排表;</span></p>', 'zhang', NULL, NULL, 0, '2017-07-08 12:07:31', 0, '已审核', 'business2.jpg', 0);
INSERT INTO `news` VALUES (63, 1, ' 使用poi和jfreechart生成excel图表图片', '<p><span style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">最近项目在频繁的操作excel，里边涉及到很多和图表有关的东西。有时候需要使用</span><a href=\"http://lib.csdn.net/base/17\" class=\"replace_word\" title=\"Java EE知识库\" target=\"_blank\" style=\"text-decoration: none; box-sizing: border-box; color: rgb(223, 52, 52); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px; font-weight: bold;\">Java</a><span style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">操作excel自带的图标，比较复杂的我们都是使用excel模板的形式实现。&nbsp;</span><br style=\"box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\" />\r\n<span style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">除此之外，也有一些功能只需要生成对应的图标样式的图片就好，我们实现的时候主要用了两种方式，一种就是由前台生成图片base64码，然后后台解码生成图片插入到excel，但是这种方式有 一定的局限性，也就是当某些功能需要后台定时生成excel的时候，就无法获取这个图片。&nbsp;</span><br style=\"box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\" />\r\n<span style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">于是我们采用了另一种方法，也就是是用jfreechart生成对应的图片，然后结合poi插入到excel对应的位置，下图是项目中使用后的真实效果：&nbsp;</span><br style=\"box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\" />\r\n<span style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">图1是前端base64码生成的：&nbsp;</span><br style=\"box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\" />\r\n<img src=\"http://img.blog.csdn.net/20160919111539678\" alt=\"这里写图片描述\" title=\"\" style=\"border: none; box-sizing: border-box; max-width: 602px; height: auto; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\" /><span style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">&nbsp;</span><br style=\"box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\" />\r\n<span style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">图2是后台jfreechart生成的：&nbsp;</span><br style=\"box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\" />\r\n<img src=\"http://img.blog.csdn.net/20160919111555459\" alt=\"这里写图片描述\" title=\"\" style=\"border: none; box-sizing: border-box; max-width: 602px; height: auto; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\" /></p>', 'zhang', NULL, NULL, 0, '2017-07-07 12:07:36', 0, '已审核', 'business3.jpg', 0);
INSERT INTO `news` VALUES (64, 6, 'jquery事件绑定解绑机制源码分析', '<p>&nbsp;<span style=\"color: rgb(51, 51, 51); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\">为什么</span><a href=\"http://lib.csdn.net/base/22\" class=\"replace_word\" title=\"jQuery知识库\" target=\"_blank\" style=\"font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px; color: rgb(223, 52, 52); text-decoration: none; box-sizing: border-box; font-weight: bold;\">jQuery</a><span style=\"color: rgb(51, 51, 51); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\">能实现不传回调函数也能解绑事件？如下：</span></p>\r\n<pre class=\"prettyprint\" name=\"code\" style=\"white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: \'Source Code Pro\', monospace; padding: 5px 5px 5px 60px; font-size: 14px; line-height: 1.45; word-break: break-all; color: rgb(51, 51, 51); border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588);\"><code class=\"hljs javascript has-numbering\" style=\"display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: \'Source Code Pro\', monospace; font-size: inherit; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;\">$(<span class=\"hljs-string\" style=\"color: rgb(0, 136, 0); box-sizing: border-box;\">&quot;p&quot;</span>).on(<span class=\"hljs-string\" style=\"color: rgb(0, 136, 0); box-sizing: border-box;\">&quot;click&quot;</span>,<span class=\"hljs-function\" style=\"box-sizing: border-box;\"><span class=\"hljs-keyword\" style=\"color: rgb(0, 0, 136); box-sizing: border-box;\">function</span><span class=\"hljs-params\" style=\"color: rgb(102, 0, 102); box-sizing: border-box;\">()</span>{</span>    alert(<span class=\"hljs-string\" style=\"color: rgb(0, 136, 0); box-sizing: border-box;\">&quot;The paragraph was clicked.&quot;</span>); });  $(<span class=\"hljs-string\" style=\"color: rgb(0, 136, 0); box-sizing: border-box;\">&quot;#box1&quot;</span>).off(<span class=\"hljs-string\" style=\"color: rgb(0, 136, 0); box-sizing: border-box;\">&quot;click&quot;</span>);</code><ul class=\"pre-numbering\" style=\"box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);\"><li style=\"box-sizing: border-box; padding: 0px 5px;\">1</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">2</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">3</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">4</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">5</li></ul><ul class=\"pre-numbering\" style=\"box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);\"><li style=\"box-sizing: border-box; padding: 0px 5px;\">1</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">2</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">3</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">4</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">5</li></ul></pre>\r\n<h1 id=\"事件绑定解绑机制\" style=\"margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: rgb(51, 51, 51); font-family: \'microsoft yahei\'; line-height: 26px;\"><a name=\"t1\" style=\"color: rgb(51, 102, 153); box-sizing: border-box;\"></a>事件绑定解绑机制</h1>\r\n<p style=\"box-sizing: border-box; margin: 0px 0px 1.1em; color: rgb(51, 51, 51); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\">调用<code style=\"box-sizing: border-box; font-family: \'Source Code Pro\', monospace; padding: 2px 4px; font-size: 12.6px; color: rgb(63, 63, 63); white-space: nowrap; border-radius: 0px; background-color: rgba(128, 128, 128, 0.0745098);\">on</code>函数的时候，将生成一份事件数据，结构如下：</p>\r\n<pre class=\"prettyprint\" name=\"code\" style=\"white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: \'Source Code Pro\', monospace; padding: 5px 5px 5px 60px; font-size: 14px; line-height: 1.45; word-break: break-all; color: rgb(51, 51, 51); border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588);\"><code class=\"hljs haskell has-numbering\" style=\"display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: \'Source Code Pro\', monospace; font-size: inherit; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;\">{     <span class=\"hljs-typedef\" style=\"box-sizing: border-box;\"><span class=\"hljs-keyword\" style=\"color: rgb(0, 0, 136); box-sizing: border-box;\">type</span>: <span class=\"hljs-keyword\" style=\"color: rgb(0, 0, 136); box-sizing: border-box;\">type</span>,</span>     origType: origType,     <span class=\"hljs-typedef\" style=\"box-sizing: border-box;\"><span class=\"hljs-keyword\" style=\"color: rgb(0, 0, 136); box-sizing: border-box;\">data</span>: <span class=\"hljs-keyword\" style=\"color: rgb(0, 0, 136); box-sizing: border-box;\">data</span>,</span>     handler: handler,     guid: guid,     selector: selector,     needsContext: needsContext,     namespace: namespace }</code><ul class=\"pre-numbering\" style=\"box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);\"><li style=\"box-sizing: border-box; padding: 0px 5px;\">1</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">2</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">3</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">4</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">5</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">6</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">7</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">8</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">9</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">10</li></ul><ul class=\"pre-numbering\" style=\"box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);\"><li style=\"box-sizing: border-box; padding: 0px 5px;\">1</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">2</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">3</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">4</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">5</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">6</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">7</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">8</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">9</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">10</li></ul></pre>\r\n<p style=\"box-sizing: border-box; margin: 0px 0px 1.1em; color: rgb(51, 51, 51); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\">并将该数据加入到元素的缓存中。jquery中每个元素都可以有一个缓存（只有有需要的时候才生成），其实就是该元素的一个属性。jquery为每个元素的每种事件都建立一个队列，用来保存事件处理函数，所以可以对一个元素添加多个事件处理函数。</p>\r\n<p>&nbsp;</p>', 'zhang', NULL, NULL, 0, '2017-07-08 12:07:39', 1, '已审核', 'business4.jpg', 0);
INSERT INTO `news` VALUES (66, 6, ' javascript基础复习之函数，定时器，erval函数', '<h2 id=\"function对象\" style=\"margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px;\">Function对象</h2>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">JS中函数就是Function对象</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">函数名就是指向Function对象的引用</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">使用函数名就可以访问函数的对象</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">函数名()是调用函数</p>\r\n<pre class=\"prettyprint\" name=\"code\" style=\"white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: \'Source Code Pro\', monospace; padding: 5px 5px 5px 60px; font-size: 14px; line-height: 1.45; word-break: break-all; color: rgb(51, 51, 51); border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588);\"><code class=\"hljs javascript has-numbering\" style=\"display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: \'Source Code Pro\', monospace; font-size: inherit; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: border-box;\"><span class=\"hljs-keyword\" style=\"color: rgb(0, 0, 136); box-sizing: border-box;\">function</span> 函数名 <span class=\"hljs-params\" style=\"color: rgb(102, 0, 102); box-sizing: border-box;\">([参数])</span> {</span> 函数体； <span class=\"hljs-keyword\" style=\"color: rgb(0, 0, 136); box-sizing: border-box;\">return</span> 返回值； }</code><ul class=\"pre-numbering\" style=\"box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);\"><li style=\"box-sizing: border-box; padding: 0px 5px;\">1</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">2</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">3</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">4</li></ul><ul class=\"pre-numbering\" style=\"box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);\"><li style=\"box-sizing: border-box; padding: 0px 5px;\">1</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">2</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">3</li><li style=\"box-sizing: border-box; padding: 0px 5px;\">4</li></ul></pre>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">定义函数对象</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">函数的返回值</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">默认返回undefined</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">可以使用return返回具体的值</p>\r\n<h2 id=\"函数的重载\" style=\"margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px;\">函数的重载</h2>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\"><strong style=\"box-sizing: border-box;\">JS的函数没有重载</strong>&nbsp;<br style=\"box-sizing: border-box;\" />\r\n调用时只要函数名一样，无论传入多少个参数，调用的都是同一个函数&nbsp;<br style=\"box-sizing: border-box;\" />\r\n没有接收到实参的参数值是undefined&nbsp;<br style=\"box-sizing: border-box;\" />\r\n所有的参数传递给<strong style=\"box-sizing: border-box;\">arguments</strong>数组对象</p>\r\n<h2 id=\"js传参比较灵活\" style=\"margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px;\"><a name=\"t2\" style=\"box-sizing: border-box; color: rgb(12, 137, 207);\"></a>JS传参比较灵活</h2>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">比如定义了</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">function sum(a,b){}</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">然后传入参数 sum(1,2,3,4);也可以</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\"><strong style=\"box-sizing: border-box;\">因为JS会把传入的参数封装到一个名为arguments的数组中，然后把arguments传给函数</strong></p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">相当于在定义的函数中有个 arguments[0];</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">然后用arguments去给参数赋值&nbsp;<br style=\"box-sizing: border-box;\" />\r\n就是</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">a = arguments[0];&nbsp;<br style=\"box-sizing: border-box;\" />\r\nb = arguments[1];</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">因为arguments是一个数组所以还有点length属性，获取函数参数的个数。【i】还可以获取指定的参数。</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\"><strong style=\"box-sizing: border-box;\">！！！可以利用arguments实现可变参数的函数。</strong></p>', 'zhang', NULL, NULL, 0, '2017-07-08 12:07:43', 1, '已审核', 'c1.jpg', 0);
INSERT INTO `news` VALUES (67, 3, ' Android--设计模式', '<p>&nbsp;<span style=\"color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; text-indent: 28px; background-color: rgb(248, 248, 248);\">一般来说，常用的设计模式有以下八种：单例、工厂、观察者、代理、命令、适配器、合成、访问者</span></p>\r\n<p style=\"margin: 10px 0px; padding: 0px; color: rgb(51, 51, 51); text-indent: 28px; font-family: 宋体; font-size: 14px; line-height: 28px; background-color: rgb(248, 248, 248);\">单例模式：目的是为了让系统中只有一个调用对象，缺点是单例使其他程序过分依赖它，而且不同单例运行在不同进程中，使得维护困难；</p>\r\n<p style=\"margin: 10px 0px; padding: 0px; color: rgb(51, 51, 51); text-indent: 28px; font-family: 宋体; font-size: 14px; line-height: 28px; background-color: rgb(248, 248, 248);\">工厂模式：生产固定的一些东西，如抽象类，缺点是产品修改麻烦；如喜欢动作片和爱情片的人分别向服务器发出同一个请求，就可以得到他们想看的影片集，相当于不同对象进行同一请求，需求均得到满足。</p>\r\n<p style=\"margin: 10px 0px; padding: 0px; color: rgb(51, 51, 51); text-indent: 28px; font-family: 宋体; font-size: 14px; line-height: 28px; background-color: rgb(248, 248, 248);\">观察者模式：就是多个对象对一个对象进行监控，如缓存；</p>\r\n<p style=\"margin: 10px 0px; padding: 0px; color: rgb(51, 51, 51); text-indent: 28px; font-family: 宋体; font-size: 14px; line-height: 28px; background-color: rgb(248, 248, 248);\">代理模式：自己的事交给别人去做，分别返回结果即可，如异步线程；</p>\r\n<p style=\"margin: 10px 0px; padding: 0px; color: rgb(51, 51, 51); text-indent: 28px; font-family: 宋体; font-size: 14px; line-height: 28px; background-color: rgb(248, 248, 248);\">命令模式：调用对象与作用对象之间分离，由中间件来协调两者之间的工作，如控制器；</p>\r\n<p style=\"margin: 10px 0px; padding: 0px; color: rgb(51, 51, 51); text-indent: 28px; font-family: 宋体; font-size: 14px; line-height: 28px; background-color: rgb(248, 248, 248);\">适配器模式：将一个接口变成用户所需要的接口，如baseadapter可以适配listview和spinner，因为它们有相同的接口</p>\r\n<p style=\"margin: 10px 0px; padding: 0px; color: rgb(51, 51, 51); text-indent: 28px; font-family: 宋体; font-size: 14px; line-height: 28px; background-color: rgb(248, 248, 248);\">合成模式：将一对多的关系转换成一对整体的关系，如listview与适配器；</p>\r\n<p style=\"margin: 10px 0px; padding: 0px; color: rgb(51, 51, 51); text-indent: 28px; font-family: 宋体; font-size: 14px; line-height: 28px; background-color: rgb(248, 248, 248);\">访问者模式：对不同的对象采取不同的处理，如instanceof。</p>', 'zhang', NULL, NULL, 0, '2017-07-08 12:07:47', 0, '已审核', 'c2.jpg', 0);
INSERT INTO `news` VALUES (68, 3, 'Android 常用布局及基本UI控件', '<p>&nbsp;<span style=\"font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\">这篇文章主要介绍多种方式实现主界面的tab，包括：&nbsp;</span><br style=\"box-sizing: border-box; font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\" />\r\n<span style=\"font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\">（1）使用Fragment实现&nbsp;</span><br style=\"box-sizing: border-box; font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\" />\r\n<span style=\"font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\">（2）使用ViewPage实现&nbsp;</span><br style=\"box-sizing: border-box; font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\" />\r\n<span style=\"font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\">（3）使用ViewPage+FragmentPageAdapter&nbsp;</span><br style=\"box-sizing: border-box; font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\" />\r\n<span style=\"font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\">（4）使用框架实现</span></p>\r\n<h2 id=\"思路\" style=\"margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; font-family: \'microsoft yahei\'; line-height: 26px;\">思路</h2>\r\n<p>&nbsp;</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\">这种方式实现的思路比较简单：&nbsp;<br style=\"box-sizing: border-box;\" />\r\n1、首先在主布局中加入FragmentLayout&nbsp;<br style=\"box-sizing: border-box;\" />\r\n2、然后在<a href=\"http://lib.csdn.net/base/17\" class=\"replace_word\" title=\"Java EE知识库\" target=\"_blank\" style=\"color: rgb(223, 52, 52); text-decoration: none; box-sizing: border-box; font-weight: bold;\">Java</a>代码中监听底部的按钮，当点击时，只需让FragmentLayout加载相应的Fragment即可</p>', 'zhang', NULL, NULL, 1, '2017-07-06 12:07:50', 0, '已审核', 'c3.jpg', 0);
INSERT INTO `news` VALUES (70, 4, ' sql查询语句', '&nbsp;<span style=\"font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\">1、</span><a href=\"http://lib.csdn.net/base/14\" class=\"replace_word\" title=\"MySQL知识库\" target=\"_blank\" style=\"font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px; color: rgb(223, 52, 52); text-decoration: none; box-sizing: border-box; font-weight: bold;\">MySQL</a><span style=\"font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\">:连接查询，级联操作&nbsp;</span>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\">一、mysql查询的五种子句</p>\r\n<pre style=\"white-space: pre-wrap; word-wrap: break-word; box-sizing: border-box; margin-top: 0px; margin-bottom: 10.5px; font-family: \'Source Code Pro\', monospace; padding: 10px; font-size: 14px; line-height: 1.45; word-break: break-all; color: rgb(51, 51, 51); border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588);\"><code style=\"box-sizing: border-box; font-family: \'Source Code Pro\', monospace; padding: 0px; font-size: inherit; color: inherit; white-space: pre; border-radius: 0px; word-wrap: normal; background-color: transparent;\">    where(条件查询)、having（筛选）、group by（分组）、order by（排序）、limit（限制结果数）     1、where常用运算符：         比较运算符             &gt; ,  &lt; ,=  , != （&lt; &gt;）,&gt;=   ,   &lt;=               in(v1,v2..vn)               between v1 and v2    在v1至v2之间（包含v1,v2）         逻辑运算符             not ( ! )  逻辑非             or ( || )    逻辑或             and ( &amp;&amp; )  逻辑与              where price&gt;=3000 and price &lt;= 5000 or price &gt;=500 and price &lt;=1000              取500-1000或者3000-5000的值             where price not between 3000 and 5000             不在3000与5000之间的值          模糊查询             like 像             通配符:             %  任意字符             _   单个字符                 where goods_name like \'诺基亚%\'                 where goods_name like \'诺基亚N__\'       2、group by 分组             一般情况下group需与统计函数（聚合函数）一起使用才有意义             如：select goods_id,goods_name,cat_id,max(shop_price) from goods group by cat_id;             这里取出来的结果中的good_name是错误的！因为shop_price使用了max函数，那么它是取最大的，而语句中使用了group by 分组，那么goods_name并没有使用聚合函数，它只是cat_id下的第一个商品，并不会因为shop_price改变而改变             mysql中的五种统计函数：             （1）max：求最大值                 select max(goods_price) from goods                   这里会取出最大的价格的值，只有值                     #查询每个栏目下价格最高的                     select cat_id,max(goods_price) from goos group by cat_id;                     #查出价格最高的商品编号                     select goods_id,max(goods_price) from goods group by goods_id;               （2）min：求最小值             （3）sum：求总数和                     #求商品库存总和                     select sum(goods_number) from goods;             （4）avg：求平均值                     #求每个栏目的商品平均价格                     select cat_id,avg(goods_price) from goods group by cat_id;             （5）count：求总行数                     #求每个栏目下商品种类                     select cat_id,count(*) from goods group by cat_id;                 ###要把每个字段名当成变量来理解，它可以进行运算###                     例：查询本店每个商品价格比市场价低多少；                     select goods_id,goods_name,goods_price-market_price from goods;                         查询每个栏目下面积压的货款                     select cat_id,sum(goods_price*goods_number) from goods group by cat_id;                  ###可以用as来给计算结果取个别名###                     select cat_id,sum(goods_price * goods_number)  as hk from goods group by cat_id                     不仅列名可以取别名，表单也可以取别名          3、having 与where 的异同点                  having与where类似，可以筛选数据，where后的表达式怎么写，having后就怎么写                 where针对表中的列发挥作用，查询数据                 having对查询结果中的列发挥作用，筛选数据                 #查询本店商品价格比市场价低多少钱，输出低200元以上的商品                 select goods_id,good_name,market_price - shop_price as s from goods having s&gt;200 ;                 //这里不能用where因为s是查询结果，而where只能对表中的字段名筛选                 如果用where的话则是：                 select goods_id,goods_name from goods where market_price - shop_price &gt; 200;                  #同时使用where与having                 select cat_id,goods_name,market_price - shop_price as s from goods where cat_id = 3 having s &gt; 200;                 #查询积压货款超过2万元的栏目，以及该栏目积压的货款                 select cat_id,sum(shop_price * goods_number) as t from goods group by cat_id having s &gt; 20000                 #查询两门及两门以上科目不及格的学生的平均分                       思路：                         #先计算所有学生的平均分                          select name,avg(score) as pj from stu group by name;                         #查出所有学生的挂科情况                         select name,score&lt;60 from stu;                                 #这里score&lt;60是判断语句，所以结果为真或假，mysql中真为1假为0                         #查出两门及两门以上不及格的学生                         select name,sum(score&lt;60) as gk from stu group by name having gk &gt; 1;                         #综合结果                         select name,sum(score&lt;60) as gk,avg(score) as pj from stu group by name having gk &gt;1;             4、order by                 （1） order by price  //默认升序排列                 （2）order by price desc //降序排列                 （3）order by price asc //升序排列，与默认一样                 （4）order by rand() //随机排列，效率不高                     #按栏目号升序排列，每个栏目下的商品价格降序排列                     select * from goods where cat_id !=2 order by cat_id,price desc;             5、limit                 limit [offset,] N                 offset 偏移量，可选，不写则相当于limit 0,N                 N     取出条目                   #取价格第4-6高的商品                 select good_id,goods_name,goods_price from goods order by good_price desc limit 3,3;          ###查询每个栏目下最贵的商品             思路：                     #先对每个栏目下的商品价格排序                     select cat_id,goods_id,goods_name,shop_price from goods order by cat_id,shop_price desc;                     #上面的查询结果中每个栏目的第一行的商品就是最贵的商品                     #把上面的查询结果理解为一个临时表[存在于内存中]【子查询】                     #再从临时表中选出每个栏目最贵的商品                     select * from (select goods_id,goods_name,cat_id,shop_price from goods order by cat_id,shop_price desc) as t group by cat_id;                     #这里使用group by cat_id是因为临时表中每个栏目的第一个商品就是最贵的商品，而group by前面没有使用聚合函数，所以默认就取每个分组的第一行数据，这里以cat_id分组               良好的理解模型：                 1、where后面的表达式，把表达式放在每一行中，看是否成立                 2、字段(列)，理解为变量，可以进行运算（算术运算和逻辑运算）                   3、 取出结果可以理解成一张临时表 </code></pre>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\">二、mysql子查询&nbsp;<br style=\"box-sizing: border-box;\" />\r\n1、where型子查询&nbsp;<br style=\"box-sizing: border-box;\" />\r\n（把内层查询结果当作外层查询的比较条件）&nbsp;<br style=\"box-sizing: border-box;\" />\r\n#不用order by 来查询最新的商品&nbsp;<br style=\"box-sizing: border-box;\" />\r\nselect goods_id,goods_name from goods where goods_id = (select max(goods_id) from goods);&nbsp;<br style=\"box-sizing: border-box;\" />\r\n#取出每个栏目下最新的产品(goods_id唯一)&nbsp;<br style=\"box-sizing: border-box;\" />\r\nselect cat_id,goods_id,goods_name from goods where goods_id in(select max(goods_id) from goods group by cat_id);</p>\r\n<pre style=\"white-space: pre-wrap; word-wrap: break-word; box-sizing: border-box; margin-top: 0px; margin-bottom: 10.5px; font-family: \'Source Code Pro\', monospace; padding: 10px; font-size: 14px; line-height: 1.45; word-break: break-all; color: rgb(51, 51, 51); border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588);\"><code style=\"box-sizing: border-box; font-family: \'Source Code Pro\', monospace; padding: 0px; font-size: inherit; color: inherit; white-space: pre; border-radius: 0px; word-wrap: normal; background-color: transparent;\">    2、from型子查询             (把内层的查询结果供外层再次查询)             #用子查询查出挂科两门及以上的同学的平均成绩                 思路：                     #先查出哪些同学挂科两门以上                     select name,count(*) as gk from stu where score &lt; 60 having gk &gt;=2;                     #以上查询结果，我们只要名字就可以了，所以再取一次名字                     select name from (select name,count(*) as gk from stu having gk &gt;=2) as t;                     #找出这些同学了，那么再计算他们的平均分                     select name,avg(score) from stu where name in (select name from (select name,count(*) as gk from stu having gk &gt;=2) as t) group by name;      3、exists型子查询             （把外层查询结果拿到内层，看内层的查询是否成立）             #查询哪些栏目下有商品，栏目表category,商品表goods                 select cat_id,cat_name from category where exists(select * from goods where goods.cat_id = category.cat_id); </code></pre>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; font-family: \'microsoft yahei\'; font-size: 14px; line-height: 26px;\">三、union的用法&nbsp;<br style=\"box-sizing: border-box;\" />\r\n（把两次或多次的查询结果合并起来，要求查询的列数一致，推荐查询的对应的列类型一致，可以查询多张表，多次查询语句时如果列名不一样，则取第一次的列名！如果不同的语句中取出的行的每个列的值都一样，那么结果将自动会去重复，如果不想去重复则要加all来声明，即union all）&nbsp;<br style=\"box-sizing: border-box;\" />\r\n## 现有表a如下&nbsp;<br style=\"box-sizing: border-box;\" />\r\nid num&nbsp;<br style=\"box-sizing: border-box;\" />\r\na 5&nbsp;<br style=\"box-sizing: border-box;\" />\r\nb 10&nbsp;<br style=\"box-sizing: border-box;\" />\r\nc 15&nbsp;<br style=\"box-sizing: border-box;\" />\r\nd 10&nbsp;<br style=\"box-sizing: border-box;\" />\r\n表b如下&nbsp;<br style=\"box-sizing: border-box;\" />\r\nid num&nbsp;<br style=\"box-sizing: border-box;\" />\r\nb 5&nbsp;<br style=\"box-sizing: border-box;\" />\r\nc 10&nbsp;<br style=\"box-sizing: border-box;\" />\r\nd 20&nbsp;<br style=\"box-sizing: border-box;\" />\r\ne 99&nbsp;<br style=\"box-sizing: border-box;\" />\r\n求两个表中id相同的和&nbsp;<br style=\"box-sizing: border-box;\" />\r\nselect id,sum(num) from (select * from ta union select * from tb) as tmp group by id;&nbsp;<br style=\"box-sizing: border-box;\" />\r\n//以上查询结果在本例中的确能正确输出结果，但是，如果把tb中的b的值改为10以查询结果的b的值就是10了，因为ta中的b也是10，所以union后会被过滤掉一个重复的结果，这时就要用union all&nbsp;<br style=\"box-sizing: border-box;\" />\r\nselect id,sum(num) from (select * from ta union all select * from tb) as tmp group by id;</p>\r\n<pre style=\"white-space: pre-wrap; word-wrap: break-word; box-sizing: border-box; margin-top: 0px; margin-bottom: 10.5px; font-family: \'Source Code Pro\', monospace; padding: 10px; font-size: 14px; line-height: 1.45; word-break: break-all; color: rgb(51, 51, 51); border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588);\"><code style=\"box-sizing: border-box; font-family: \'Source Code Pro\', monospace; padding: 0px; font-size: inherit; color: inherit; white-space: pre; border-radius: 0px; word-wrap: normal; background-color: transparent;\">        #取第4、5栏目的商品，按栏目升序排列，每个栏目的商品价格降序排列，用union完成         select goods_id,goods_name,cat_id,shop_price from goods where cat_id=4 union select goods_id,goods_name,cat_id,shop_price from goods where cat_id=5 order by cat_id,shop_price desc;         【如果子句中有order by 需要用( ) 包起来，但是推荐在最后使用order by，即对最终合并后的结果来排序】         #取第3、4个栏目，每个栏目价格最高的前3个商品，结果按价格降序排列          (select goods_id,goods_name,cat_id,shop_price from goods where cat_id=3 order by shop_price desc limit 3) union  (select goods_id,goods_name,cat_id,shop_price from goods where cat_id=4 order by shop_price desc limit 3) order by shop_price desc;  四、左连接，右连接，内连接              现有表a有10条数据，表b有8条数据，那么表a与表b的笛尔卡积是多少？                 select * from ta,tb   //输出结果为8*10=80条          1、左连接            以左表为准，去右表找数据，如果没有匹配的数据，则以null补空位，所以输出结果数&gt;=左表原数据数              语法：select n1,n2,n3 from ta left join tb on ta.n1= ta.n2 [这里on后面的表达式，不一定为=，也可以&gt;，&lt;等算术、逻辑运算符]【连接完成后，可以当成一张新表来看待，运用where等查询】              #取出价格最高的五个商品，并显示商品的分类名称             select goods_id,goods_name,goods.cat_id,cat_name,shop_price from goods left join category on goods.cat_id = category.cat_id order by  shop_price desc limit 5;                2、右连接             a left join b 等价于 b right join a             推荐使用左连接代替右连接             语法：select n1,n2,n3 from ta right join tb on ta.n1= ta.n2        3、内连接             查询结果是左右连接的交集，【即左右连接的结果去除null项后的并集（去除了重复项）】             mysql目前还不支持 外连接（即左右连接结果的并集,不去除null项）             语法：select n1,n2,n3 from ta inner join tb on ta.n1= ta.n2     #########              例：现有表a                     name  hot                      a        12                      b        10                      c        15                 表b:                     name   hot                       d        12                       e        10                       f         10                       g        8                 表a左连接表b，查询hot相同的数据                 select a.*,b.* from a left join b on a.hot = b.hot                 查询结果：                     name  hot   name  hot                       a       12     d       12                       b       10     e       10                       b       10     f        10                       c       15     null    null                 从上面可以看出，查询结果表a的列都存在，表b的数据只显示符合条件的项目                           再如表b左连接表a，查询hot相同的数据                     select a.*,b.* from b left join a on a.hot = b.hot                     查询结果为：                     name  hot   name  hot                       d       12     a       12                       e        10    b       10                       f        10     b      10                       g        8     null    null                 再如表a右连接表b，查询hot相同的数据</code></pre>', 'zhang', NULL, NULL, 0, '2017-07-08 12:07:55', 0, '已审核', 'c4.jpg', 0);
INSERT INTO `news` VALUES (71, 4, '统计函数与分组查询', '&nbsp;<span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px; text-align: justify; text-indent: 28px; font-size: 14px;\">搜索引擎用来爬行和访问页面的程序被称为蜘蛛，也叫做机器人。搜素引擎蜘蛛访问网站页面的时候就和你使用浏览器访问的过程一样，蜘蛛发出访问页面的请求，服务器会返回HTML代码，蜘蛛程序把这些代码存到原来页面的数据中，搜索引擎为了提高爬行和抓取的速度，都会使用多个蜘蛛分布爬行。</span>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px;\"><span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px; text-align: justify; text-indent: 28px;\"><br />\r\n</span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px;\"><span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px; text-align: justify; text-indent: 28px;\"><span style=\"font-size: 24px;\">一、搜素引擎蜘蛛的基本原理</span></span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px;\"><span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px; text-align: justify; text-indent: 28px;\"><span style=\"font-size: 24px;\"><br />\r\n</span></span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px;\"><span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px; text-align: justify; text-indent: 28px;\">如果说互联网是一个蜘蛛网的话，那么搜索引擎蜘蛛就是在这个网上爬来爬去的蜘蛛。</span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px;\"><span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px; text-align: justify; text-indent: 28px;\"><br />\r\n</span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px;\"><span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px; text-align: justify; text-indent: 28px;\">网络蜘蛛是通过网页的链接地址来寻找网页的，从网站的一个页面（首页）开始，读取网页的内容，找到网页中其他链接地址，通过这些链接地址寻找下一个网页，知道把这个网站所有的网页都找到。</span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px;\"><span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px; text-align: justify; text-indent: 28px;\"><br />\r\n</span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px;\"><span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px; text-align: justify; text-indent: 28px;\">对于搜索引擎来说，要把互联网上所有的页面抓取下来几乎不可能，其中部分原因是技术问题，100亿网页的容量是100*2000G字节，这么多的数据下载需要很多机器下载很长时间才能把所有的网页下面，而且数据量太大，在搜索的时候有效率方面也会受到影响。</span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px;\"><span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px; text-align: justify; text-indent: 28px;\"><br />\r\n</span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px;\"><span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px; text-align: justify; text-indent: 28px;\">所以搜索引擎只对一些重要的网页网页进行抓取，所以有些蜘蛛就对一些不太重要的网站设置了访问层数，所以你的网站如果有三层链接，但是蜘蛛限制访问的层数是两层，那么你第三层的网页便不会被蜘蛛所访问。对于网站设计者来说，扁平化的网站有利于搜索引擎抓取更多的网页。</span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px;\"><span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px; text-align: justify; text-indent: 28px;\"><br />\r\n</span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px;\"><span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px; text-align: justify; text-indent: 28px;\"><span style=\"white-space: pre;\">网络蜘蛛在访问网站网页的时候，经常会遇到加密数据和网页权限的问题，有些网页是需要会员权限才能访问。</span></span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px;\"><span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px; text-align: justify; text-indent: 28px;\"><span style=\"white-space: pre;\"><br />\r\n当然，网站的所有者可以通过协议让网络蜘蛛不去抓取，但对于一些出售报告的网站，他们希望搜索引擎能搜索到他们的报告，但又不能完全免费的让搜索者查看，这样就需要给网络蜘蛛提供相应的用户名和密码。<br />\r\n网络蜘蛛可以通过所给的权限对这些网页进行网页抓取，从而提供搜索，而当搜索者点击查看该网页的时候，同样需要搜索者提供相应的权限验证。</span></span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px;\"><span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px; text-align: justify; text-indent: 28px;\"><span style=\"white-space: pre;\"><br />\r\n</span></span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px;\"><span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px; text-align: justify; text-indent: 28px;\"><span style=\"font-size: 24px;\">二、追踪链接</span></span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; text-align: justify; text-indent: 28px;\">由于蜘蛛为了能够抓取网上尽量多的页面，它会追踪网页上的简介，<span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px;\">从一个页面爬到下一个页面，就好像是蜘蛛在蜘蛛网上爬行那样。整个互联网网站都是相互链接组成的，也就是说，搜索引擎蜘蛛从任何一个页面出发最终都会爬完所有页面。</span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; text-align: justify; text-indent: 28px;\"><span style=\"color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; line-height: 23px;\">网站和页面链接结构太过于复杂，所以蜘蛛只有采用一定的方法才能够爬完所有页面，最简单的爬行策略有3种：</span></p>\r\n<p style=\"margin: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; text-align: justify; text-indent: 28px;\">&nbsp;</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\"><span style=\"font-size: 18px;\"><strong>1、最佳优先</strong></span></p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">最佳优先搜索策略按照一定的网页分析<a href=\"http://lib.csdn.net/base/31\" class=\"replace_word\" title=\"算法与数据结构知识库\" target=\"_blank\" style=\"color: rgb(223, 52, 52); text-decoration: none; font-weight: bold;\">算法</a>，预测候选URL与目标网页的相似度，或与主题的相关性，并选取评价最好的一个或几个URL进行抓取，它只访问经过网页分析算法预测为&ldquo;有用&rdquo;的网页。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">存在的一个问题是，在爬虫抓取路径上的很多相关网页可能被忽略，因为最佳优先策略是一种局部最优搜索算法，因此需要将最佳优先结合具体的应用进行改进，以跳出局部最优点，据马海祥博客的研究发现，这样的闭环调整可以将无关网页数量降低30%~90%。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\"><span style=\"font-size: 18px;\"><strong>2、深度优先</strong></span></p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">深度优先是指蜘蛛沿着发现的链接一直向前爬行，直到前面再也没有其他链接，然后返回到第一个页面，沿着另一个链接再一直往前爬行。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\"><span style=\"font-size: 18px;\"><strong>3、广度优先</strong></span></p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">广度优先是指蜘蛛在一个页面发现多个链接时，不是顺着一个链接一直向前，而是把页面上所有链接都爬一遍，然后再进入第二层页面沿着第二层上发现的链接爬向第三层页面。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">从理论上说，无论是深度优先还是广度优先，只要给蜘蛛足够的时间，都能爬完整个互联网。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\"><span style=\"font-size: 22px;\"><strong>三、搜索引擎蜘蛛工作中的信息收集</strong></span></p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">信息收集模块包括&ldquo;蜘蛛控制&rdquo;和&ldquo;网络蜘蛛&rdquo;两部分，&ldquo;蜘蛛&rdquo;这个称呼形象的描述出了信息收集模块在网络数据形成的&ldquo;Web&rdquo;上进行信息获取的功能。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">总体而言，网络蜘蛛从种子网页出发，通过反复下载网页并从文档中寻找未曾见过的URL，达到访问其他网页得以遍历Web的目的。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">而其工作策略一般则可以分为累积式抓取（cumulative crawling）和增量式抓取（incremental crawling）两种。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\"><span style=\"font-size: 18px;\"><strong>1、累积式抓取</strong></span></p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">累积式抓取是指从某一个时间点开始，通过遍历的方式抓取系统所能允许存储和处理的所有网页。在理想的软硬件环境下，经过足够的运行时间，累积式抓取的策略可以保证抓取到相当规模的网页集合。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">但在马海祥看来由于Web数据的动态特性，集合中网页的被抓取时间点是不同的，页面被更新的情况也不同，因此累积式抓取到的网页集合事实上并无法与真实环境中的网络数据保持一致。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\"><span style=\"font-size: 18px;\"><strong>2、增量式抓取</strong></span></p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">与累积式抓取不同，增量式抓取是指在具有一定量规模的网络页面集合的基础上，采用更新数据的方式选取已有集合中的过时网页进行抓取，以保证所抓取到的数据与真实网络数据足够接近。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">进行增量式抓取的前提是，系统已经抓取了足够数量的网络页面，并具有这些页面被抓取的时间信息。面向实际应用环境的网络蜘蛛设计中，通常既包括累积式抓取，也包括增量式抓取的策略。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">累积式抓取一般用于数据集合的整体建立或大规模更新阶段，而增量式抓取则主要针对数据集合的日常维护与即时更新。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">在确定了抓取策略之后，如何从充分利用网络带宽，合理确定网页数据更新的时间点就成了网络蜘蛛运行策略中的核心问题。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">总体而言，在合理利用软硬件资源进行针对网络数据的即时抓取方面，已经形成了相对比较成熟的技术和实用性解决方案，马海祥觉得在这方面目前所需解决的主要问题是如何更好的处理动态网络数据问题（如数量越来越庞大的Web2.0数据等），以及更好的根据网页质量修正抓取策略的问题。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\"><span style=\"font-size: 22px;\"><strong>四、<a href=\"http://lib.csdn.net/base/14\" class=\"replace_word\" title=\"MySQL知识库\" target=\"_blank\" style=\"color: rgb(223, 52, 52); text-decoration: none;\">数据库</a></strong></span></p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">为了避免重复爬行和抓取网址，搜索引擎会建立一个数据库，记录已被发现还没有抓取的页面和已经被抓取的页面，那么数据库中的URL是怎么来的呢？</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\"><span style=\"font-size: 18px;\"><strong>1、人工录入种子网站</strong></span></p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">这个简单的来说，就是我们建好一个新站后，向百度、Google或360提交的网址收录。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\"><span style=\"font-size: 18px;\"><strong>2、蜘蛛抓取页面</strong></span></p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">如果搜索引擎蜘蛛在爬取的过程中，发现了新连接URL，数据库中没有，就会存入待访问数据库（网站观察期）。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">蜘蛛按重要性从待访问数据库中提取URL，访问并抓取页面，然后把这个URL从待访问地址库中删除，放进已访问地址库中，所以马海祥建议各位站长在网站观察期的时候尽量有规律的更新网站是必要的。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\"><span style=\"font-size: 18px;\"><strong>3、站长提交网站</strong></span></p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">一般来说，提交网站只是把网站存入待访问数据库，如果网站持久不更新蜘蛛也不会光顾，搜索引擎收录的页面都是蜘蛛自己追踪链接得到的。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">所以你提交给搜索引擎其实用处不大，还是要根据后期你网站更新程度来考虑，搜索引擎更喜欢自己沿着链接发现新页面，当然如果说你的SEO技术够老练，并且有这能力，可以试一下，说不定会有意想不到的效果，不过，对于一般在站长来说，马海祥还是建议让蜘蛛自然的爬行和抓取到新站页面。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\"><span style=\"font-size: 22px;\"><strong>五、吸引蜘蛛</strong></span></p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">虽然理论上说蜘蛛可以爬行和抓取所有页面，但实际上是不可能完成的，那么SEO人员想要收录更多的页面就只有想办法引诱蜘蛛抓取。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">既然抓不了所有页面，那么我们就要让它抓取重要页面，因为重要页面在索引中起到重要决定，直接影响排名的因素，哪么那些页面算是比较重要的呢？对此，马海祥也特意整理了以下几个我认为比较重要页面，具体有这么几个特点：</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\"><span style=\"font-size: 18px;\"><strong>1、网站和页面权重</strong></span></p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">质量高、年龄老的网站被给予很高的权重，这种网站上的页面蜘蛛爬行的深度比较高，所以会有更多的内页被收录。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\"><span style=\"font-size: 18px;\"><strong>2、页面更新度</strong></span></p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">蜘蛛每次爬行都会把页面数据储存起来，如果第二次爬行时发现此页面与第一次收录的内容完全一样，说明页面没有更新，蜘蛛也没必要经常再来爬行和抓取。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">如果页面内容经常更新，蜘蛛就会频繁的爬行和抓取，那么，页面上的新链接自然的会被蜘蛛更快的追踪和抓取，这也就是为什么需要每天更新文章。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\"><span style=\"font-size: 18px;\"><strong>3、导入链接</strong></span></p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">无论是外部链接还是同一个网站的内部链接，要被蜘蛛抓取，就必须有导入链接进入页面，否则蜘蛛根本不知道页面的存在。此时的URL链接起着非常重要的作用，内链的重要性发挥出来了。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">这也就是为什么大多数站长或SEO都要高质量<a target=\"_blank\" href=\"http://www.mahaixiang.cn/yqlj/\" style=\"color: rgb(255, 0, 0); text-decoration: none; outline: invert none medium;\"><span style=\"color: rgb(51, 51, 51);\">友情链接</span></a>，因为蜘蛛从对方网站爬行到你网站之次数多，深度也高。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\"><span style=\"font-size: 18px;\"><strong>4、与首页点击距离</strong></span></p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">一般来说网站首页权重最高，大部分外部链接都指向首页，蜘蛛访问最频繁的也是首页，离首页点击距离越近，页面权重越高，被蜘蛛爬行的机会也就越大。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">这也就是为什么要求网站框架建设点击三次就能查看完整个网站的意思。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\"><span style=\"font-size: 22px;\"><strong>六、蜘蛛爬行时的复制内容检测</strong></span></p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">一般都知道在搜索引擎索引环节中中会进行去重处理，其实在蜘蛛爬行的时候已经在进行检测，当蜘蛛爬行和抓取文件时会进行一定程度的复制内容检测，遇到权重低的网站上大量转载或抄袭内容时，很可能不再继续爬行。</p>\r\n<p style=\"margin: 0px; padding: 8px 0px; font-size: 14px; text-align: justify; line-height: 23px; word-wrap: break-word; color: rgb(51, 51, 51); font-family: \'Microsoft YaHei\', SimHei, Verdana, Arial, sans-serif; text-indent: 28px;\">所以对于新站来说切莫采集和抄袭，这也就是为什么很多站长查看日志的时候发现了蜘蛛，但是页面从来没有被抓取的原因，因为爬行发现是重复内容那么它讲放弃抓取也就只停留在爬行过的阶段。</p>', 'admin', NULL, NULL, 0, '2017-07-09 12:07:58', 0, '已审核', 'c5.jpg', 0);
INSERT INTO `news` VALUES (73, 1, 'JavaWeb核心基础面试知识深度详解', '&nbsp;<strong style=\"color: rgb(255, 0, 0); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px;\"><span style=\"font-family: \'Microsoft YaHei\'; font-size: 14px;\">一、Servlet是什么？JSP是什么？它们的联系与区别是什么？</span></strong>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><span style=\"color: rgb(51, 102, 255);\"><strong>Servlet</strong></span>是<span style=\"font-size: 14px;\">Java编写的</span>运行在Servlet容器的服务端程序，狭义的Servlet是指Servlet接口，广义的Servlet是指任何实现Servlet接口的类，我们一般理解的为后者。Servlet的作用是接收浏览器发给服务器的请求Request，经过处理后，将返回响应Response给浏览器。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><span style=\"color: rgb(51, 102, 255);\"><strong>JSP</strong></span>是一种后端脚本语言，是为了解决Html是静态的，而Servlet输出动态页面又太复杂的问题而出现的，通过JSP标签、动作、内置对象提供方便的生成动态网页功能，是一种后端渲染技术。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><br />\r\n</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 102, 255);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">联系和区别：</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">1、<span style=\"color: rgb(51, 102, 255);\"><strong>JSP其实就是基于Servlet实现的，JSP生命周期</strong></span>：</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">&nbsp; &nbsp; &nbsp;（1）解析阶段：Servlet容器解析JSP代码，如果有错则报错；</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">&nbsp; &nbsp;&nbsp; （2）翻译阶段：Servlet容器翻译JSP代码为Servlet源文件；</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">&nbsp; &nbsp; &nbsp;（3）编译阶段：Servlet容器编译Servlet源代码，生成Servlet字节码类文件；</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">&nbsp; &nbsp; &nbsp; &nbsp;&hellip;&hellip;剩下就是Servlet的生命周期，会在下面介绍。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">2、JSP注重视图显示、Servlet注重控制，在传统的MVC架构中，JSP是View，Servlet是Controller。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">3、JSP在修改静态内容时不需要重新编译。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><hr />\r\n</div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(255, 0, 0);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">二、Servlet API</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><strong><span style=\"color: rgb(51, 102, 255);\"><span style=\"font-family: \'Microsoft YaHei\';\">核心包：javax.servlet与javax.servlet.http</span></span></strong></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">核心类\\接口：</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><span style=\"color: rgb(51, 102, 255);\"><strong>1、javax.servlet.Servlet：</strong></span>Servlet核心接口，定义了init()、service()、destroy<span style=\"font-size: 14px;\">()</span>有关Servlet 生命周期的方法。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><span style=\"color: rgb(51, 102, 255);\"><strong>2、javax.servlet.ServletConfig：</strong></span>Servlet配置接口，定义了getServletContext<span style=\"font-size: 14px;\">()</span>，主要用于获取ServletContext实例。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><span style=\"color: rgb(51, 102, 255);\"><strong>3、javax.servlet.ServletContex：</strong></span>Servlet上下文接口，相当于Web应用的总管家。定义了getAtrribute<span style=\"font-size: 14px;\">(String name)</span>、setAttribute<span style=\"font-size: 14px;\">(String name, Object object)、getInitParameter(String name)、getContextPath()、getRequestDispatcher(String path)等方法，主要用于应用间通信，获取web应用资源、访问服务器文件资源、输出日志等功能。</span></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><span style=\"color: rgb(51, 102, 255);\"><strong>4、javax.servlet.GenericServlet：</strong></span>该包下唯一抽象类，实现了ServletConfig、Servlet接口，为两个接口方法提供默认的实现方式。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><img src=\"http://img.blog.csdn.net/20160915212113098?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\" style=\"border: none;\" /></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><hr />\r\n</div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(255, 0, 0);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">三、如何使用Servlet</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-weight: bold;\"><span style=\"color: rgb(51, 102, 255);\"><span style=\"font-family: \'Microsoft YaHei\';\"><span style=\"font-size: 14px;\">1、</span><span style=\"font-size: 14px;\">继承GenericServlet类（通用）</span></span></span></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">（1）GenericServlet类有一个关键的设计，定义了一个私有的ServletConfig成员变量，在init()方法中，由Servlet容器传入ServletConfig对象与之匹配。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">（2）GenericServlet类中唯一一个抽象方法是Service方法，子类必须实现Service方法，以为用户提供特定的服务。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><br />\r\n</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 102, 255);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">2、<span style=\"font-size: 14px;\">继承HttpServlet类，是GenericServlet的子类，重写了Service方法，提供了HTTP的相关服务实现。用户需要做的事，根据实际情况，重写doPost()、doGet()等方法。</span></span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><hr />\r\n</div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(255, 0, 0);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">四、Servlet生命周期</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 102, 255);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">1、初始化阶段</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-family: \'Microsoft YaHei\';\">（1）将编译后的servlet字节码文件读入内存；</span></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-family: \'Microsoft YaHei\';\">（2）Servlet容器创建ServletConfig，并与ServletContext对象建立关联关系，即调用ServletConfig的getServletContext()方法会获取到ServletContext对象。</span></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-family: \'Microsoft YaHei\';\">（3）创建Servlet对象。</span></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-family: \'Microsoft YaHei\';\">（4）调用GenericServlet的init(ServletConfig config)方法，建立Servlet对象与ServletConfig对象的关联。</span></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 102, 255);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">初始化时机：</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-family: \'Microsoft YaHei\';\">（1）未配置&lt;load-on-startup&gt;属性的Servlet被客户端首次访问时才会被初始化。</span></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-family: \'Microsoft YaHei\';\">（2）配置&lt;load-on-startup&gt;属性的Servlet在web容器启动时就会按配置的数值按顺序被初始化。</span></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-family: \'Microsoft YaHei\';\"><br />\r\n</span></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-family: \'Microsoft YaHei\';\"><span style=\"color: rgb(51, 102, 255);\"><strong>2、运行时阶段</strong></span>，调用Servlet类的Service()方法。当Servlet将响应返回后，Servlet容器会销毁HttpServletRequest对象与HttpServletResponse对象。</span></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-family: \'Microsoft YaHei\';\"><br />\r\n</span></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-family: \'Microsoft YaHei\';\"><span style=\"color: rgb(51, 102, 255);\"><strong>3、销毁阶段</strong></span>，在web容器终止时，会先调用所有Servlet的destroy()方法。</span></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><hr />\r\n</div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(255, 0, 0);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">五、ServletContextListener监视器</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-family: \'Microsoft YaHei\';\">通过实现ServletContextListener接口，实现contextInitialized(ServletContextEvent sce)与contextDestroyed(ServletContextEvent sce)方法，其中可以通过参数的getServletCotext()方法获取ServletContext对象以完成监听工作。</span></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-family: \'Microsoft YaHei\';\"><br />\r\n</span></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 102, 255);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">注意：Servlet、Listener、Filter三者的加载顺序为：Listener&gt;Filter&gt;Servlet</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><hr />\r\n</div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\">\r\n<div style=\"font-size: 14px;\"><strong><span style=\"color: rgb(255, 0, 0);\"><span style=\"font-family: \'Microsoft YaHei\';\">六、请求转发与重定向特点以及它们的区别</span></span></strong></div>\r\n<div><span style=\"color: rgb(51, 102, 255);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">1、请求转发：HttpServletRequest.getRequestDispatcher(String path).forward(request, response);</span></strong></span></div>\r\n<div><span style=\"color: rgb(51, 153, 102);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">特点：</span></strong></span></div>\r\n<div><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-family: \'Microsoft YaHei\';\">（1）服务器内部转发，浏览器URL不会改变，对用户透明。整体体现的是一个请求与一个响应。</span></span></div>\r\n<div><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-family: \'Microsoft YaHei\';\">（2）请求转发前，会清空响应缓冲区。</span></span></div>\r\n<div><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-family: \'Microsoft YaHei\';\">（3）如果转发的为Servlet或JSP（JSP也是Servlet），就会直接将当前HttpServletRequest对象与HttpServletResponse对象转交给目标Servlet或JSP的Service方法，处理后将响应结果返回给前端。</span></span></div>\r\n<div><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-family: \'Microsoft YaHei\';\">（4）如果转发的为Html静态文档，则就读取文档中数据发送到前端。</span></span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\"><span style=\"color: rgb(51, 51, 51);\">（5）</span><span style=\"font-size: 14px;\">请求转发不会执行转发方法之后的代码</span></span></div>\r\n<div><span style=\"color: rgb(51, 102, 255);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">2、重定向：HttpServletResponse.sendRedirect(String path);</span></strong></span></div>\r\n<div><span style=\"color: rgb(51, 153, 102);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">特点：</span></strong></span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\"><span style=\"color: rgb(51, 51, 51);\">（1）客户端外部转发，浏览器URL会发生改变。在Servlet调用重定向后，会返回302临时重定向状态码，响应内容为待重定向</span><span style=\"color: rgb(51, 51, 51); font-size: 14px;\">路径</span><span style=\"color: rgb(51, 51, 51);\">。然后，浏览器就会再次发出请求，请求路径为刚刚相应内容中的路径。整体体现的是两个请求与两个响应。</span></span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\">（2）重定向前，也会清空响应缓冲区。</span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\">（3）<span style=\"font-size: 14px;\">而重定向会执行重定向方法后的代码</span></span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\"><br />\r\n</span></div>\r\n<div><span style=\"color: rgb(51, 102, 255);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">区别汇总：</span></strong></span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\">1、请求转发在服务端完成，重定向在客户端完成。</span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\">2、请求转发速度快，重定向速度慢。</span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\">3、请求转发是一次请求，一次响应；而重定向是两次请求，两次响应。</span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\">4、请求转发不会执行转发方法之后的代码；而重定向会执行重定向方法后的代码。</span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\">5、请求转发URL不会发生改变；而重定向URL会发生改变。</span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\">6、请求转发必须在同一台服务器下完成；而重定向可以在不同服务器下完成。</span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\"><br />\r\n</span></div>\r\n<div><span style=\"color: rgb(51, 102, 255);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">注意：请求转发与重定向的资源路径表示是有区别的</span></strong></span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\">请求转发的path一般使用&quot;/资源名&quot;，这里的 \'/\' 就代表了项目根路径 &quot;http://localhost:8080/项目名/&quot;；</span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\">而重定向的path一般使用context.getContextPath() + &quot;/资源名&quot;，不能直接使用&quot;/资源名&quot;，因为在重定向中&quot;/&quot;代表了Web站点的根路径&quot;http://localhost:8080&quot;。</span></div>\r\n<div><hr />\r\n</div>\r\n</div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(255, 0, 0);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">七、如何访问Servlet容器中的其他Web应用</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\">\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\">在Service中编写如下代码：</span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\">ServletContext otherContext = context.getContext(&quot;/otherApp&quot;);</span></div>\r\n</div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">otherContext.getRequestDispatcher(&quot;/资源名&quot;).forward(request, response);</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><hr />\r\n</div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(255, 0, 0);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">八、如何保证Servlet线程安全</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">1、保证变量作用域合理，线程私有的变量要定义在方法中。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">2、共享变量要用保证线程安全，可以使用加锁、atomic类、volatile关键字实现。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><hr />\r\n</div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(255, 0, 0);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">九、JSP九大内置对象（详情可参看博客<a target=\"_blank\" href=\"http://blog.csdn.net/zhangliangzi/article/details/49965209\" style=\"text-decoration: none; color: rgb(12, 137, 207);\">http://blog.csdn.net/zhangliangzi/article/details/49965209</a>）</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">1、request对象&mdash;&mdash;代表javax.servlet.http.HttpServletRequest对象</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">2、response对象&mdash;&mdash;代表javax.servlet.http.HttpServletResponse对象</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">3、session对象&mdash;&mdash;代表javax.servlet.http.HttpSession对象</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">4、application对象&mdash;&mdash;代表javax.servlet.ServletContext对象</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">5、pageContext对象&mdash;&mdash;代表javax.servlet.jsp.pageContext对象</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">6、page对象&mdash;&mdash;代表this</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">7、config对象&mdash;&mdash;代表javax.servlet.ServletConfig对象</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">8、out对象&mdash;&mdash;代表javax.servlet.jsp.jspWriter对象</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">9、exception对象&mdash;&mdash;代表java.lang.Exception对象</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><hr />\r\n</div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(255, 0, 0);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">十、Session与Cookie</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><span style=\"color: rgb(51, 102, 255);\"><strong>为什么要使用Session与Cookie：</strong></span>Web应用一般使用HTTP协议传输数据，HTTP是一种无状态协议，完成数据交换后客户端与服务端的连接就会关闭。所以服务端无法根据HTTP请求区分请求者。但区分请求者身份是是非常有意义的，比如一个购物车系统，添加一件商品到购物车，服务端必须区分是哪个用户添加的商品；而且如果一段时间内某个用户多次发出请求，那么就可以对用户的相关数据进行缓存，提高访问效率。这都可以通过Session与Cookie实现。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><br />\r\n</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><strong><span style=\"color: rgb(51, 102, 255);\">Cookie与Session的区别在于：</span></strong>Cookie存在于客户端，Session存在于服务端。Cookie的存储数量是有限制的，安全性也更差。Session是基于Cookie实现的，但服务端为了获得较高的存取速度，会把Session放到内存中，在高并发环境下会增大服务器压力。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><br />\r\n</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 102, 255);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">Cookie机制：</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><span style=\"color: rgb(51, 153, 102);\"><strong>Cookie</strong></span>基于浏览器的支持，具有&ldquo;不可跨域名性&rdquo;，浏览器只能访问当前域名网站的Cookie。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 153, 102);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">Cookie的常见属性有如下几个：</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><strong>String name</strong>&mdash;&mdash;Cookie的名称，一旦创建便不能更改；</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><strong>Object value</strong>&mdash;&mdash;Cookie的值；</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><strong>int maxAge</strong>&mdash;&mdash;Cookie失效时间，单位为秒；</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><strong>boolean secure</strong>&mdash;&mdash;Cookie是否使用HTTPS或SSL的安全数据，传输前要加密，默认为false</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><strong>String domain</strong>&mdash;&mdash;Cookie的作用域名，比如设置为&quot;.google.com&quot;，第一个字符必须为点，代表着以google.com为结尾的域名才可以访问该Cookie。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><strong>String path</strong>&mdash;&mdash;Cookie的作用项目名，比如设置为&quot;/webApp/&quot;，最后一个字符必须为斜线，代表着contextPath为&quot;/webApp&quot;的程序才可以访问该Cookie。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><strong><span style=\"color: rgb(51, 153, 102);\"><span style=\"font-family: \'Microsoft YaHei\';\">Cookie使用：</span></span></strong></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\">\r\n<div align=\"left\" style=\"margin: 0px; color: rgb(64, 64, 64); font-size: 14px; orphans: 2; widows: 2; padding: 0px;\">\r\n<div><span style=\"font-weight: 700;\"><span style=\"font-family: \'Microsoft YaHei\';\">Cookie cookie = new Cookie(&quot;name&quot;,&quot;StringValue&quot;); // 新建Cookie</span></span></div>\r\n<div><strong><span style=\"font-family: \'Microsoft YaHei\';\">Cookie[] cookies = request.getCookie(); //获取客户端提交的所有cookie</span></strong></div>\r\n<div><strong><span style=\"font-family: \'Microsoft YaHei\';\">cookie.setDomain(&quot;.leeon.top&quot;); //设置作用域名</span></strong></div>\r\n</div>\r\n<div align=\"left\" style=\"margin: 0px; color: rgb(64, 64, 64); font-size: 14px; orphans: 2; widows: 2; padding: 0px;\">\r\n<div><strong><span style=\"font-family: \'Microsoft YaHei\';\">cookie.setPath(&quot;/testApp/&quot;); //设置作用项目路径</span></strong></div>\r\n<div><strong><span style=\"font-family: \'Microsoft YaHei\';\">cookie.setSecure(true); //设置安全属性</span></strong></div>\r\n<div><span style=\"font-weight: 700;\"><span style=\"font-family: \'Microsoft YaHei\';\">cookie.setMaxAge(Integer.MAX_VALUE); // 设置生命周期为永久；</span></span></div>\r\n</div>\r\n<div align=\"left\" style=\"margin: 0px; orphans: 2; widows: 2; padding: 0px;\">\r\n<div><span style=\"color: rgb(64, 64, 64);\"><span style=\"font-weight: 700;\"><span style=\"font-family: \'Microsoft YaHei\';\">response.addCookie(cookie); // 输出到客户端</span></span></span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\"><strong><span style=\"color: rgb(64, 64, 64);\">在网页URL栏输入：</span></strong><span style=\"font-weight: 700; color: rgb(64, 64, 64); font-size: 14px;\">javascript:alert (document. cookie)</span><strong><span style=\"color: rgb(64, 64, 64);\">&nbsp;可输出当前页面cookie</span></strong></span></div>\r\n<div><span style=\"color: rgb(64, 64, 64);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">注意：</span></strong></span></div>\r\n<div><span style=\"color: rgb(64, 64, 64);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">Coookie不能修改与删除，修改可通过创建同名Cookie后覆盖原Coolkie；删除可通过设置setMaxAge方法中的参数为0。</span></strong></span></div>\r\n<div><span style=\"font-family: \'Microsoft YaHei\';\"><span style=\"color: rgb(64, 64, 64); font-size: 14px;\"><strong>setMaxAge方法中的参</strong></span><span style=\"font-weight: 700; color: rgb(64, 64, 64); font-size: 14px;\">如果设置为负值，则为存放在内存中的临时Cookie，关闭浏览器即失效；如果设置为0，则代表使Cookie失效。</span></span></div>\r\n</div>\r\n</div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\"><br />\r\n</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 102, 255);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">Session会话机制：</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 153, 102);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">Session基于Cookie的工作流程：</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">（1）当用户通过浏览器进程第一次请求一个支持会话的资源时，Servlet容器会为这个会话创建一个HttpSession对象，并为其分配一个唯一的ID，当前会话就此开始。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">（2）把这个唯一的ID以name为JSESSIONID的Cookie形式添加到响应中，返回给客户端保存。（当Cookie被禁用时，使用URL重写机制，在URL后添加;jsessionid=XXX以传输HttpSession对象标识）</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">（3）当浏览器进程再次请求这个支持会话的资源时，会在请求头中加上一直保持着的JSESSIONID，Servlet容器会在HTTP请求头中自动查找这个Cookie（也可以通过HttpSession.getId()方法主动获取），如果找到，就取出对应HttpSession对象（其实用户第一次访问，也会进行相同的查询，因为查询不到，才会执行创建操作）。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 153, 102);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">Session使用：</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">HttpSession session = request.getSession(); //获取Session对象</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">session.setAtrribute(&quot;name&quot;, &quot;StringValue&quot;);//加入session</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">session.getAttribute(&quot;name&quot;);//获取session</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">session.removeAtrribute(&quot;name&quot;);//删除session</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">session.setMaxInactiveInterval(int second);//设置超时时间，单位为秒，默认20分钟</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">session.getLastAccessedTime();//返回Session的最后活跃时间</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"color: rgb(51, 153, 102);\"><strong><span style=\"font-family: \'Microsoft YaHei\';\">Session持久化：</span></strong></span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">1、StandarManager是默认的Session Manager（用来管理Session）。它的实现机制是：当Tomcat服务器关闭或重启，或Web应用被重新加载时，会将内存中所有的HttpSession对象保存到文件系统中，默认的文件路径是：%CATALINA_HOME%\\work\\Catalina\\&lt;applicaton-name&gt;\\SESSIONS.ser</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">重启Tomcat后，Tomcat服务器把SESSIONS.ser中的持久化HttpSession对象加载到内存中。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">2、PersistentManager能够把HttpSession对象保存到Session Store中，它提供了比较StandarManager更灵活的管理功能，具有容错能力，控制内存中HttpSession对象的数目等。</span></div>\r\n<div style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px; font-size: 16px;\"><span style=\"font-family: \'Microsoft YaHei\';\">Tomcat实现Session Store的接口为org.apache.catalina.session.Store，目前提供了两个实现这一接口的类：org.apache.catalina.session.FileStore和org.apache.catalina.session.JDBCStore。FileStore会将HttpSession对象保存到文件系统中；而JDBCStore则将HttpSession对象保存到数据库表中。</span></div>', 'admin', NULL, NULL, 0, '2017-07-08 12:08:04', 0, '已审核', 'c6.jpg', 0);
INSERT INTO `news` VALUES (74, 1, 'TCP建立连接三次握手和释放连接四次握手', '&nbsp;<span style=\"color: rgb(51, 51, 51); font-size: 14px; line-height: 26px; font-family: SimSun;\"><span style=\"color: rgb(0, 102, 0);\">在谈及TCP建立连接和释放连接过程，先来简单认识一下</span><span style=\"color: rgb(0, 102, 0);\">TCP报文段首部格式</span></span><span style=\"font-size: 14px; line-height: 26px; color: rgb(0, 102, 0); font-family: SimSun;\">的的几个名词</span><span style=\"font-size: 14px; line-height: 26px; color: rgb(0, 102, 0); font-family: SimSun;\">（这里只是简单说明，具体请查看相关教程）</span>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0); font-family: SimSun;\"><img src=\"http://img.blog.csdn.net/20160914140730874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" width=\"500\" height=\"300\" alt=\"\" style=\"border: none; max-width: 100%;\" /><br />\r\n</span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"font-family: SimSun;\"><span style=\"color: rgb(0, 102, 0);\">&nbsp; &nbsp;</span><span style=\"color: rgb(0, 102, 0);\"><strong>&nbsp;序列号seq：</strong>占4个字节，用来标记数据段的</span><span style=\"color: rgb(0, 102, 0);\">顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</span><br />\r\n<span style=\"color: rgb(0, 102, 0);\">&nbsp;&nbsp;</span><span style=\"color: rgb(0, 102, 0);\"><strong>&nbsp; 确认号ack：</strong>占4个字节，</span><span style=\"color: rgb(0, 102, 0);\">期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</span><br />\r\n<span style=\"color: rgb(0, 102, 0);\">&nbsp; &nbsp;&nbsp;</span><span style=\"color: rgb(0, 102, 0);\"><strong>确认ACK：</strong></span><span style=\"color: rgb(0, 102, 0);\">占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</span><br />\r\n<span style=\"color: rgb(0, 102, 0);\">&nbsp; &nbsp;<strong>&nbsp;</strong></span><span style=\"color: rgb(0, 102, 0);\"><strong>同步SYN：</strong></span><span style=\"color: rgb(0, 102, 0);\">连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。</span><span style=\"color: rgb(153, 0, 0);\">SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</span><br />\r\n<span style=\"color: rgb(0, 102, 0);\">&nbsp; &nbsp;&nbsp;</span><span style=\"color: rgb(0, 102, 0);\"><strong>终止FIN：</strong></span><span style=\"color: rgb(0, 102, 0);\">用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</span><br />\r\n</span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"font-family: SimSun;\"><span style=\"color: rgb(0, 102, 0);\">&nbsp; &nbsp;</span><span style=\"color: rgb(153, 0, 0);\">&nbsp;PS：<strong>ACK、<strong>SYN和<strong>FIN这些</strong></strong></strong>大写的单词表示标志位，其值要么是1，要么是0；<strong>ack、seq</strong>小写的单词表示序号。</span></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><strong><span style=\"font-family: SimSun;\">一、TCP建立连接三次握手</span></strong></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><strong><span style=\"font-family: SimSun;\">（1）、三次握手的过程</span></strong></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0); font-family: SimSun;\">&nbsp; &nbsp;1）主机A向主机B发送TCP连接请求数据包，其中包含主机A的初始序列号seq(A)=x。</span><span style=\"font-family: SimSun;\"><span style=\"font-size: 12px; color: rgb(153, 0, 0);\">（其中报文中同步标志位SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）</span></span><span style=\"color: rgb(0, 102, 0); font-family: SimSun;\">；<br />\r\n&nbsp; &nbsp;2）主机B收到请求后，会发回连接确认数据包。</span><span style=\"font-family: SimSun;\"><span style=\"font-size: 12px; color: rgb(153, 0, 0);\">（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含主机B的初始序列号seq(B)=y，以及主机B对主机A初始序列号的确认号ack(B)=seq(A)+1=x+1）</span><br />\r\n<span style=\"color: rgb(0, 102, 0);\">&nbsp; &nbsp;3）第三次，主机A收到主机B的确认报文后，还需作出确认，即发送一个序列号seq(A)=x+1；确认号为ack(A)=y+1的报文；</span><br />\r\n</span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><img src=\"http://img.blog.csdn.net/20160914100821925?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\" style=\"border: none; max-width: 100%; font-family: SimSun; color: rgb(0, 102, 0);\" /></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><strong><span style=\"font-family: SimSun;\">（2）为什么需要第三次握手?</span></strong></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><span style=\"font-family: SimSun;\">&nbsp; &nbsp; &nbsp;还要再发送一次确认是为了，防止已失效的连接请求报文段突然又传到了B，因而产生错误。<br />\r\n&nbsp; &nbsp; &nbsp;已失效的报文段：正常情况下：A发出连接请求，但因为丢失了，故而不能收到B的确认。于是A重新发出请求，然后收到确认，建立连接，数据传输完毕后，释放连接，A发了2个，一个丢掉，一个到达，没有&ldquo;已失效的报文段&rdquo;<br />\r\n&nbsp; &nbsp; &nbsp;但是，某种情况下，A的第一个在某个节点滞留了，延误到达，本来这是一个早已失效的报文段，但是在A发送第二个，并且得到B的回应，建立了连接以后，这个报文段竟然到达了，于是B就认为，A又发送了一个新的请求，于是发送确认报文段，同意建立连接，假若没有三次的握手，那么这个连接就建立起来了（有一个请求和一个回应），此时，A收到B的确认，但A知道自己并没有发送建立连接的请求，因为不会理睬B的这个确认，于是呢，A也不会发送任何数据，而B呢却以为新的连接建立了起来，一直等待A发送数据给自己，此时B的资源就被白白浪费了。但是采用三次握手的话，A就不发送确认，那么B由于收不到确认，也就知道并没有要求建立连接。<br />\r\n</span></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><span style=\"font-family: SimSun;\">&nbsp; &nbsp; &nbsp;简而言之：</span></span><span style=\"color: rgb(0, 102, 0); font-family: 宋体;\">第三次握手，主机</span><span style=\"color: rgb(0, 102, 0); font-family: SimSun;\">A</span><span style=\"color: rgb(0, 102, 0); font-family: 宋体;\">发送一次确认是为了防止：</span><span style=\"font-family: SimSun; color: rgb(255, 0, 0);\">如果客户端迟迟没有收到服务器返回的确认报文，这时他会放弃连接，重新启动一条连接请求；但问题是：服务器不知客户端没收到，所以他会收到两个连接请求，白白浪费了一条连接开销。</span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><span style=\"font-family: SimSun;\"><br />\r\n</span></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><strong><span style=\"font-family: SimSun;\">二、TCP释放连接四次握手</span></strong></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><strong><span style=\"font-family: SimSun;\">（1）四次握手过程</span></strong></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><span style=\"font-family: SimSun;\">　　假设主机A为客户端，主机B为服务器，其释放TCP连接的过程如下：</span></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><span style=\"font-family: SimSun;\">&nbsp; &nbsp; 1） 关闭客户端到服务器的连接：首先客户端A发送一个FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u</span></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><span style=\"font-family: SimSun;\">&nbsp;　 2） 服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。<br />\r\n&nbsp; 　3）&nbsp;关闭服务器到客户端的连接：也是发送一个FIN给客户端。<br />\r\n&nbsp;　 4） 客户段收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加1。<br />\r\n</span></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><span style=\"font-family: SimSun;\">&nbsp; &nbsp; &nbsp;首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。<br />\r\n</span></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><strong><span style=\"font-family: SimSun;\"><img src=\"http://img.blog.csdn.net/20160914101234549?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\" style=\"border: none; max-width: 100%;\" /><br />\r\n</span></strong></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><span style=\"font-family: SimSun;\">&nbsp; &nbsp; 　主机A发送FIN后，进入终止等待状态， 服务器B收到主机A连接释放报文段后，就立即给主机A发送确认，然后服务器B就进入close-wait状态，此时TCP服务器进程就通知高层应用进程，因而从A到B的连接就释放了。此时是&ldquo;半关闭&rdquo;状态。即A不可以发送给B，但是B可以发送给A。<br />\r\n此时，若B没有数据报要发送给A了，其应用进程就通知TCP释放连接，然后发送给A连接释放报文段，并等待确认。A发送确认后，进入time-wait，注意，此时TCP连接还没有释放掉，然后经过时间等待计时器设置的2MSL后，A才进入到close状态。</span></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"font-family: SimSun;\"><br />\r\n<strong style=\"color: rgb(0, 102, 0);\">（2）为什么要等待2MSL呢?</strong><br />\r\n<span style=\"color: rgb(0, 102, 0);\">&nbsp; &nbsp; MSL即Maximum Segment Lifetime，也就是</span><strong><span style=\"color: rgb(153, 0, 0);\">最大</span></strong><span style=\"color: rgb(153, 0, 0);\"><strong>报文生存时间</strong></span><span style=\"color: rgb(0, 102, 0);\">，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。引用《TCP/IP详解》中的话：&ldquo;它(MSL)是任何报文段被丢弃前在网络内的最长时间&rdquo;。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。</span></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"font-family: SimSun; line-height: 21px;\"><span style=\"color: rgb(0, 102, 0);\">&nbsp; &nbsp;&nbsp;TCP的TIME_WAIT状态需要等待2MSL，当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间，等待2MSL时间主要目的是</span><span style=\"color: rgb(153, 0, 0);\">怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。</span><span style=\"color: rgb(0, 102, 0);\">不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。</span></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"font-family: SimSun; color: rgb(0, 102, 0);\">&nbsp; &nbsp; 概括原因如下：</span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><span style=\"font-family: SimSun;\">&nbsp; &nbsp; ①、为了保证A发送的最后一个ACK报文段能够到达B。即最后这个确认报文段很有可能丢失，那么B会超时重传，然后A再一次确认，同时启动2MSL计时器，如此下去。如果没有等待时间，发送完确认报文段就立即释放连接的话，B就无法重传了（连接已被释放，任何数据都不能出传了），因而也就收不到确认，就无法按照步骤进入CLOSE状态，即必须收到确认才能close。<br />\r\n&nbsp; &nbsp; ②、防止&ldquo;已失效的连接请求报文段&rdquo;出现在连接中。经过2MSL，那些在这个连接持续的时间内，产生的所有报文段就可以都从网络中消失。即在这个连接释放的过程中会有一些无效的报文段滞留在楼阁结点，但是呢，经过2MSL这些无效报文段就肯定可以发送到目的地，不会滞留在网络中。这样的话，在下一个连接中就不会出现上一个连接遗留下来的请求报文段了。<br />\r\n可以看出：B结束TCP连接的时间比A早一点，因为B收到确认就断开连接了，而A还得等待2MSL.</span></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><span style=\"font-family: SimSun;\"><br />\r\n</span></span></div>\r\n<div style=\"color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; margin: 0px; padding: 0px;\">\r\n<div style=\"margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\"><strong>（3）为什么TCP释放连接需要四次？</strong></span></div>\r\n<div style=\"margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\">&nbsp; &nbsp; &nbsp; TCP建立连接要进行三次握手，而断开连接要进行四次。这是由于TCP的半关闭造成的。因为TCP连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的<strong>数据发送任务</strong>，就发送一个FIN来向另一方通告将要终止这个方向的连接。</span></div>\r\n<div style=\"margin: 0px; padding: 0px;\"><span style=\"color: rgb(0, 102, 0);\">&nbsp;&nbsp;<strong>&nbsp; &nbsp;注意：</strong></span></div>\r\n<div style=\"margin: 0px; padding: 0px;\"><span style=\"color: rgb(153, 0, 0);\">&nbsp; &nbsp; &nbsp;1）<strong>发送了FIN只是表示这端不能继续发送数据(应用层不能再调用send发送)，但是还可以接收数据。</strong>收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据，比如：如主机A收到主机B的FIN断开TCP连接请求，只是表示主机B已经发送完数据，主机A收到FIN后作出应答，并终止这个方向的数据传输，此时处于半关闭状态。但是主机A仍然可以发送数据的，只有当主机A发送完数据并发送FIN给主机B时，主机B才停止这个方向的数据传输，并关闭TCP连接。</span></div>\r\n<div style=\"margin: 0px; padding: 0px;\"><span style=\"color: rgb(153, 0, 0);\">&nbsp; &nbsp; &nbsp;2）在很多时候，TCP连接的断开都会由TCP层自动进行，例如你CTRL+C终止你的程序，TCP连接依然会正常关闭，你可以写代码试试。</span></div>\r\n</div>', 'admin', NULL, NULL, 0, '2017-07-08 12:08:08', 0, '已审核', 'crt1.jpg', 0);
INSERT INTO `news` VALUES (75, 1, ' java常见基础知识汇总', '&nbsp;\r\n<h3 id=\"什么导致线程阻塞\" style=\"margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px;\"><font size=\"5\" face=\"黑体\" style=\"box-sizing: border-box;\">什么导致线程阻塞</font></h3>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\"><font color=\"red\" size=\"4\" style=\"box-sizing: border-box;\">线程的阻塞</font></p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\"><font size=\"4\" style=\"box-sizing: border-box;\">为了解决对共享存储区的访问冲突，<a href=\"http://lib.csdn.net/base/17\" class=\"replace_word\" title=\"Java EE知识库\" target=\"_blank\" style=\"text-decoration: none; box-sizing: border-box; color: rgb(223, 52, 52); font-weight: bold;\">Java</a>&nbsp;引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持.</font></p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\"><font size=\"4\" style=\"box-sizing: border-box;\">阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</font></p>\r\n<ul style=\"box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">\r\n    <li style=\"box-sizing: border-box;\"><font size=\"4\" style=\"box-sizing: border-box;\"><strong style=\"box-sizing: border-box;\"><em style=\"box-sizing: border-box;\">sleep() 方法</em></strong>：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。</font></li>\r\n    <li style=\"box-sizing: border-box;\"><font size=\"4\" style=\"box-sizing: border-box;\"><strong style=\"box-sizing: border-box;\"><em style=\"box-sizing: border-box;\">suspend() 和 resume() 方法</em></strong>：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。</font></li>\r\n    <li style=\"box-sizing: border-box;\"><font size=\"4\" style=\"box-sizing: border-box;\"><strong style=\"box-sizing: border-box;\"><em style=\"box-sizing: border-box;\">yield() 方法</em></strong>：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.</font></li>\r\n    <li style=\"box-sizing: border-box;\"><font size=\"4\" style=\"box-sizing: border-box;\"><strong style=\"box-sizing: border-box;\"><em style=\"box-sizing: border-box;\">wait() 和 notify() 方法</em></strong>：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.</font></li>\r\n</ul>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\"><font size=\"4\" style=\"box-sizing: border-box;\">初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。上述的核心区别导致了一系列的细节上的区别。</font></p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\"><font size=\"4\" style=\"box-sizing: border-box;\">首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。</font></p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\"><font size=\"4\" style=\"box-sizing: border-box;\">其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。</font></p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\"><font size=\"4\" style=\"box-sizing: border-box;\">wait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的<a href=\"http://lib.csdn.net/base/31\" class=\"replace_word\" title=\"算法与数据结构知识库\" target=\"_blank\" style=\"text-decoration: none; box-sizing: border-box; color: rgb(223, 52, 52); font-weight: bold;\">算法</a>（如信号量算法），并用于解决各种复杂的线程间通信问题。</font></p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\"><font size=\"4\" style=\"box-sizing: border-box;\">谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。</font></p>\r\n<h3 id=\"抽象类与接口区别\" style=\"margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; line-height: 35px;\"><a name=\"t1\" style=\"box-sizing: border-box; color: rgb(12, 137, 207);\"></a><font size=\"5\" face=\"黑体\" style=\"box-sizing: border-box;\">抽象类与接口区别</font></h3>\r\n<ul style=\"box-sizing: border-box; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 14px; line-height: 35px;\">\r\n    <li style=\"box-sizing: border-box;\"><font size=\"4\" style=\"box-sizing: border-box;\"><strong style=\"box-sizing: border-box;\"><em style=\"box-sizing: border-box;\">默认的方法实现</em></strong>&nbsp;抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现</font></li>\r\n    <li style=\"box-sizing: border-box;\"><font size=\"4\" style=\"box-sizing: border-box;\"><strong style=\"box-sizing: border-box;\"><em style=\"box-sizing: border-box;\">实现</em></strong>&nbsp;子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现。</font></li>\r\n    <li style=\"box-sizing: border-box;\"><font size=\"4\" style=\"box-sizing: border-box;\"><strong style=\"box-sizing: border-box;\"><em style=\"box-sizing: border-box;\">构造器</em></strong>&nbsp;抽象类可以有构造器 接口不能有构造器</font></li>\r\n    <li style=\"box-sizing: border-box;\"><font size=\"4\" style=\"box-sizing: border-box;\"><strong style=\"box-sizing: border-box;\"><em style=\"box-sizing: border-box;\">与正常Java类的区别</em></strong>&nbsp;除了你不能实例化抽象类之外，它和普通Java类没有任何区 接口是完全不同的类型</font></li>\r\n    <li style=\"box-sizing: border-box;\"><font size=\"4\" style=\"box-sizing: border-box;\"><strong style=\"box-sizing: border-box;\"><em style=\"box-sizing: border-box;\">访问修饰符</em></strong>&nbsp;抽象方法可以有public、protected和default这些修饰符 接口方法默认修饰符是public。你可以使用其它修饰符。&nbsp;<br style=\"box-sizing: border-box;\" />\r\n    -<font size=\"4\" style=\"box-sizing: border-box;\"><strong style=\"box-sizing: border-box;\"><em style=\"box-sizing: border-box;\">main方法</em></strong>&nbsp;<br style=\"box-sizing: border-box;\" />\r\n    抽象方法可以有main方法并且我们可以运行它&nbsp;<br style=\"box-sizing: border-box;\" />\r\n    接口没有main方法，因此我们不能运行它。&nbsp;<br style=\"box-sizing: border-box;\" />\r\n    -<font size=\"4\" style=\"box-sizing: border-box;\">&nbsp;<strong style=\"box-sizing: border-box;\"><em style=\"box-sizing: border-box;\">多继承</em></strong>&nbsp;<br style=\"box-sizing: border-box;\" />\r\n    抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。&nbsp;<br style=\"box-sizing: border-box;\" />\r\n    -<font size=\"4\" style=\"box-sizing: border-box;\">&nbsp;<strong style=\"box-sizing: border-box;\"><em style=\"box-sizing: border-box;\">速度</em></strong>&nbsp;<br style=\"box-sizing: border-box;\" />\r\n    它比接口速度要快&nbsp;<br style=\"box-sizing: border-box;\" />\r\n    接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</font></font></font></font></li>\r\n    <li style=\"box-sizing: border-box;\"><font size=\"4\" style=\"box-sizing: border-box;\"><strong style=\"box-sizing: border-box;\"><em style=\"box-sizing: border-box;\">添加新方法</em></strong>&nbsp;<br style=\"box-sizing: border-box;\" />\r\n    如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。&nbsp;<br style=\"box-sizing: border-box;\" />\r\n    如果你往接口中添加方法，那么你必须改变实现该接口的类。</font></li>\r\n</ul>', 'admin', NULL, NULL, 1, '2017-07-08 12:08:12', 12, '已审核', 'article4.jpg', 0);
INSERT INTO `news` VALUES (76, 6, '购物车功能的优化完善', '', 'admin', NULL, NULL, 0, '2017-07-08 12:08:17', 0, '已审核', 'crt2.jpg', 0);
INSERT INTO `news` VALUES (77, 6, '设计模式之策略模式', '策略模式定义了一系列的算法，并将灭一个算法封装起来，而且使他们还可以相互替换，策略模式让算法独立于使用它的客户而独立变化', 'admin', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'crt3.jpg', 0);
INSERT INTO `news` VALUES (78, 2, '阿里云表格存储使用教程 ', '表格存储（Table Store）是构建在阿里云飞天分布式系统之上的分布式NoSQL数据存储服务，根据99.99%的高可用以及11个9的数据可靠性的标准设计。表格存储通过数据分片和负载均衡技术，实现数据规模与访问并发上的无缝扩展，提供海量结构化数据的存储和实时访问。', 'admin', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'e1.jpg', 0);
INSERT INTO `news` VALUES (79, 3, '带你轻松了解Android 设计模式——Builder模式', '通过一个对象然后链式调用了他的属性，最后再显示出来。这就是Android中非常常用的一种设计模式，Builder模式。目前主流的框架也都会运用到Builder模式，如：OKhttp，EventBus等都可以看到Builder模式的身影。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'e2.jpg', 0);
INSERT INTO `news` VALUES (80, 4, '事务隔离级别和脏读的快速入门', '仅从ACID或非ACID角度考虑问题是不够的，你应知道你的数据库支持何种事务隔离级别。\n\n一些数据库宣称自己具有“最终一致性”，但却可能对重复查询返回不一致的结果。\n\n相比于你所寻求的数据库，一些数据库提供更高的事务隔离级别。\n\n脏读可导致同一记录得到两个版本，或是完全地丢失一条记录。\n\n在同一事务中多次重新运行同一查询后，可能会出现幻读。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'e3.jpg', 0);
INSERT INTO `news` VALUES (81, 5, '玩转云镜像制作之packer篇', '1.DevOps之基础设施即代码(Infrastracture as Code) \n什么是DevOps呢？按照维基百科的定义，DevOps（Development和Operations的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'eg1.jpg', 0);
INSERT INTO `news` VALUES (82, 6, 'HDFS体系结构及读写流程', ' HDFS全称是Hadoop Distributed System。HDFS是为以流的方式存取大文件而设计的。适用于几百MB，GB以及TB，并写一次读多次的场合。而对于低延时数据访问、大量小文件、同时写和任意的文件修改，则并不是十分适合。\nHDFS(Hadoop Distributed File System)默认的最基本的存储单位是64M的数据块。\n和普通文件系统相同的是，HDFS中的文件是被分成64M一块的数据块存储的。', '', NULL, NULL, 0, '2017-07-08 12:08:17', 1, '已审核', 'eg2.jpg', 0);
INSERT INTO `news` VALUES (83, 1, '使用python机器学习', 'python经常作为机器学习的首选，有一个统计，50%以上的机器学习开发者使用python。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'eg3.jpg', 0);
INSERT INTO `news` VALUES (84, 2, 'Spark初学者配置windows10下的开发环境', '解压hadoop与spark到一英文路径的文件夹下（可以解压到不同的文件夹，但是必须是英文路径），并将winutils.exe放到hadoop下的bin文件夹下', '', NULL, NULL, 0, '2017-07-08 12:08:17', 1, '已审核', 'eg4.jpg', 0);
INSERT INTO `news` VALUES (85, 3, 'Android 解锁 Gradle 依赖新姿势', '在根目录添加 dependencies.gradle 文件,然后在 dependencies.gradle 中配置我们原本在 build.gradle 中依赖的内容', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'ent1.jpg', 0);
INSERT INTO `news` VALUES (86, 4, '数据库SQL优化大总结之 百万级数据库优化方案', '1.对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。\n2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'ent2.jpg', 0);
INSERT INTO `news` VALUES (87, 5, '一招搞定数据完整性校验', '很多筒子都很关心数据在客户端和服务器之间传输时有可能会出错。阿里云OSS现在支持对各种方式上传的object返回其crc64值，客户端可以和本地计算的crc64值做对比，从而完成数据完整性的验证。 \nOSS对新上传的object进行crc64的计算，并将结果存储为object的元信息存储，随后在返回的response header 中增加x-oss-hash-crc64ecma头部，表示其crc64值，该64位CRC根据 ECMA-182标准 计算得出。 \n对于crc64上线之前就已经存在于OSS上的object, OSS不会对其计算crc64值，所以获取此类object时不会返回其crc64值。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'ent3.jpg', 0);
INSERT INTO `news` VALUES (88, 6, '机器网关服务', '机器网关服务为在同一个OSGi框架实例上运行的机器适配器提供了集中的配置、监控和管理。 \n通过通用API展示来自多个机器适配器的实时数据流，还可以用作服务多个客户端的数据聚合器。 \n机器网关服务的架构灵活，可扩展，这样，开发者可以针对实时数据流自定义适配器。默认提供MQTT、OPC-UA、Modbus和健康状况监控机器适配器。 ', '', NULL, NULL, 0, '2017-07-08 12:08:17', 1, '已审核', 'f1.jpg', 0);
INSERT INTO `news` VALUES (89, 1, '单变量线性回归原理解析', ' 给出一个房价预测的例子，x轴是房子的大小，y轴是房子的价格，图中标注了一些房子作为数据集，而这些点被称为标注数据(labeled data)，利用这样的数据来预测的方法称为：监督学习。监督学习分为两类：分类与回归，此时，作为预测房价的这个例子是监督学习中的回归例子。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'f2.jpg', 0);
INSERT INTO `news` VALUES (90, 2, '容器和实时资源监控的必知要素', '您是否实时监控您的容器资源？如果没有，那意味着您可能没有对之进行有效监控。在快速变化的、动态的微服务环境中，即使是几秒钟以前的监视数据也可能不再可行。为了防止中断，您需要实时监控。\n\n在这篇文章中，我解释了为什么对容器资源进行实时监控是很重要的，以及实时监控中您应该关注的容器指标。\n\n首先要明确的是，这篇文章并非在为哪个特定的容器监控产品站台。虽然现在有很多可供容器使用的实时监控平台，但我认为最好的做法，还是充分了解容器监控的基本要素，而不是只关注特定产品的某些特性。如果您知道为保证容器基础设施正常运行需要实时监视什么，那么你一定能选出最佳的、最能满足你的实时监控需求的工具。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'f3.jpg', 0);
INSERT INTO `news` VALUES (91, 3, 'ListView嵌套RadioButton导致的多选', '1、首先ListView获取点击事件需要设置RadioButton的焦点android:focusable=”false” \n2、通过一个List集合管理所有的RadioButton，然后在点击事件中，清空所有的状态。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '0', 'f4.jpg', 0);
INSERT INTO `news` VALUES (92, 4, '数据库压缩技术探索', '作为数据库，在系统资源（CPU、内存、SSD、磁盘等）一定的前提下，我们希望：\n\n存储的数据更多：采用压缩，这个世界上有各种各样的压缩算法；\n访问的速度更快：更快的压缩（写）/解压（读）算法、更大的缓存。\n几乎所有压缩算法都严重依赖上下文：\n\n位置相邻的数据，一般情况下相关性更高，内在冗余度更大；\n上下文越大，压缩率的上限越大（有极限值）。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '0', 'f5.jpg', 0);
INSERT INTO `news` VALUES (93, 5, '代码质量以及内存泄露排查总结', '众所周知iOS Crash类型分为Objective-C Exception 和 Signal。其中Objective-C 的 Exception 是比较好处理的，在 Crash 的时候会有详细的描述信息，而错误case也相对集中一些，比如未加保护而任意的使用MutableArray && MutableDictionary 导致添加一个nil对象引起Crash,比如下面这样的代码', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '0', 'f6.jpg', 0);
INSERT INTO `news` VALUES (94, 6, 'Hadoop之常用shell命令整理', '整理以下hdfs的常用shell命令，以便以后用到，可以直接参考，提高开发效率。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'f7.jpg', 0);
INSERT INTO `news` VALUES (95, 1, 'Java 里如何实现线程间通信？', '正常情况下，每个子线程完成各自的任务就可以结束了。不过有的时候，我们希望多个线程协同工作来完成某个任务，这时就涉及到了线程间通信了。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 1, '已审核', 'f8.jpg', 0);
INSERT INTO `news` VALUES (96, 2, '常见的十大机器学习算法', '机器学习算法的广义分类大概有三种：监督式学习、无监督学习、强化学习。 \n监督学习由一个目标变量或结果变量（或因变量）组成。这些变量由已知的一系列预示变量（自变量）预测而来。利用这一系列变量，我们生成一个将输入值映射到期望输出值的函数。这个训练过程会一直持续，直到模型在训练数据上获得期望的精确度。监督式学习的例子有：回归、决策树、随机森林、K ? 近邻算法、逻辑回归等。 \n无监督式学习没有任何目标变量或结果变量要预测或估计。这个算法用在不同的组内聚类分析。这种分析方式被广泛地用来细分客户，根据干预的方式分为不同的用户组。非监督式学习的例子有：关联算法和 K ? 均值算法。 \n强化学习，这个算法训练机器进行决策。它的工作机制是机器被放在一个能让它通过反复试错来训练自己的环境中。机器从过去的经验中进行学习，并且尝试利用了解最透彻的知识作出精确的商业判断。 强化学习的例子有马尔可夫决策过程。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'fcrt1.jpg', 0);
INSERT INTO `news` VALUES (97, 3, 'Android AlertDialog嵌套listview点击无响应', 'listView中的item把焦点抢去了，设置android:focusable=false即可解决。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'fcrt2.jpg', 0);
INSERT INTO `news` VALUES (98, 4, 'SQL、NewSQL和NoSQL融合研究与实践', '近几年，各类大数据技术迅猛发展，企业中数据处理量呈现几十到几百倍增长，数据类型也从传统结构化数据，延伸到实时流数据，以及各类非结构化数据。传统数据库单一技术包打天下的局面无法适应复杂多变的海量数据处理，从而出现了各类NewSQL技术和NoSQL技术，出现不同技术解决不同场景应用的局面。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'fcrt3.jpg', 0);
INSERT INTO `news` VALUES (99, 5, '浅谈Web网站架构演变过程', '我们以javaweb为例，来搭建一个简单的电商系统，看看这个系统可以如何一步步演变。\n\n该系统具备的功能：\n\n用户模块：用户注册和管理\n商品模块：商品展示和管理\n交易模块：创建交易和管理', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'sai.jpg', 0);
INSERT INTO `news` VALUES (100, 6, '10分钟全面了解持续交付平台云效', '云效，创立于2012年，是业内领先的面向企业的一站式研发提效平台，历经阿里集团众多业务打磨，覆盖研发测试全流程，通过研发综合效能管理和专项自动化提效工具，提升研发效能，降低研发成本，支撑技术团队实现真正的CI/CD和独立交付。云效目前有10多种产品，每个产品能够提供怎样的解决方案和服务？以下内容让您全面深入了解云效！', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'l1.jpg', 0);
INSERT INTO `news` VALUES (101, 1, 'Java 进阶巩固：什么是注解以及运行时注解的使用', '注解是一种元数据（描述数据的数据）\n\n描述作用，不会直接生效，需要在编译前/运行时获取注解信息 \n代码检查', '', NULL, NULL, 0, '2017-07-08 12:08:17', 3, '已审核', 'l2.jpg', 0);
INSERT INTO `news` VALUES (102, 2, '远程过程调用 (RPC)', '远程过程调用 (RPC) 是一种协议，通过它一个应用可以在无需了解网络细节的情况下去请求位于网络中另一台电脑上的应用所提供的服务。过程调用有时也称为方法调用或者子程序调用。\nRPC 基于 CS (client-server) 模型。请求程序是客户端，提供服务的程序是服务端。就像一个一般的本地过程调用那样，RPC 也是一个同步操作，要求请求程序一直阻塞直到收到远程过程的返回结果。尽管如此，通过使用轻量级的多进程或者共享同一地址空间的多线程等手段仍然能够实现多 RPC 调用的并发效果。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'l3.jpg', 0);
INSERT INTO `news` VALUES (103, 3, '快速提升 Android App 的代码覆盖率', '编写移动应用程序很难，编写好的和可维护的应用程序就更加困难了。在开发过程中，我们需要保证对代码库的每次修改不会降低代码质量和功能的可用性。\n\n在现代的移动应用开发中，很难想象在没有编写测试特别是单元测试的情况下，你可以做出一个可靠的和可维护的应用。但我们经常遇到一个问题：要编写多少的测试用例才能足够保证这段代码能够被测试正确的覆盖。嗯，这没有明确的答案，但今天我想介绍一个名为 JaCoCo 这款很棒的工具，它有助于保证有价值的代码被单元测试覆盖到。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'l4.jpg', 0);
INSERT INTO `news` VALUES (104, 4, '微信Android架构历史', '到了微信架构的v2.x时代，随着业务的快速发展，消息通知不及时和Android 2.3版本之前webview内存泄露问题开始突显。由于代码、内存、apk大小都在增长，对系统资源的占用越来越多，导致微信进程容易被系统回收。因此微信开始转向多进程架构，独立的通信进程保持长连接的稳定性，独立的webview进程也阻隔了内存泄露导致的问题。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 's1.jpg', 0);
INSERT INTO `news` VALUES (105, 5, '架构和设计有什么区别？', '架构是事物结构的一个规划。设计是事物创建的一个规划。\n弄明白架构和设计之间有什么区别的一个简单办法是去将一个办公大楼的架构与其内部设计进行对比。架构提供的是一系列的结构，比如房间、楼梯的样例，诸如水、暖、通风和空调之类的基础服务。内部设计提供的是内部材料、装饰风格、地板、家具以及咖啡机和厨房之类的附加服务。', '', NULL, NULL, 0, '2017-07-08 12:08:17', 4, '已审核', 's2.jpg', 0);
INSERT INTO `news` VALUES (106, 6, 'CDN的技术原理及资源访问流程', 'CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络\"边缘\"（边缘服务器），使用户可以就近取得所需的内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因所造成的用户访问网站响应速度慢的问题。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 's3.jpg', 0);
INSERT INTO `news` VALUES (107, 1, ' Java实现二叉树和常见的排序', '二叉树分为根节点，双亲节点，叶子节点，节点的度不能超多2，左孩子小于双亲节点，右孩子大于双亲节点。', '', NULL, NULL, 0, '2017-07-08 12:08:17', 3, '已审核', 'sport1.jpg', 0);
INSERT INTO `news` VALUES (108, 2, '高可用高并发大型系统架构设计经验浅谈', '某移动互联网公司的服务器端架构图，它支撑了国内外数百万客户端的访问请求，它有如下特点：\n1、多层级集群，从Web服务器层、NoSQL层级数据库层都实现了集群，这样使得每一层的响应时间大大缩短，从而能够在单位时间内响应更多请求；\n2、NoSQL应用（Memcached)，在NoSQL领域Memcached和Redis都有大量的用户群，在这个架构里使用的是Memcached。\n3、数据库读写分离，当前大多数数据库服务器支持主从机制或订阅发布机制，这样一来就为读写分离创造了条件，减少了数据库竞争死锁出发条件，使响应时间大为缩短（非数据库集群情况下还可以考虑分库机制）。\n4、负载均衡，Nginx实现Web服务器的负载均衡，Memcached自带负载均衡实现。', '', NULL, NULL, 0, '2017-07-08 12:08:17', 2, '已审核', 'sai2.jpg', 0);
INSERT INTO `news` VALUES (109, 3, 'Android 深入理解Loader机制', 'Android开发者都经历过APP UI开发不当 会造成OverDraw，导致APP UI渲染过慢，但是很多人却没听过OverLoad，OverLoad一般是由于开发者在主线程操作耗时操作，导致程序变慢 甚至出现的anr的现象，那么Android早已为这种现象提供完美的解决方案，本文介绍带来的Android Loader机制。', '', NULL, NULL, 0, '2017-07-08 12:08:17', 1, '已审核', 'sai3.jpg', 0);
INSERT INTO `news` VALUES (110, 4, '简单几招捕获Oracle递归SQL调用源头', '通常，DBA 确定通过 Oracle 的顶级活动会话图确定 Top SQL，有了 SQL 的执行会话信息和 SQL 文本，可以和开发人员确定 Top SQL 来自哪些应用模块的。有时候，Oracle DBA 需要自己确认 SQL 的来源，本文将演示如何使用 Oracle 提供丰富的跟踪功能，来确认递归 SQL 的调用者来源。', '', NULL, NULL, NULL, '2017-07-08 12:08:17', 0, '已审核', 'sg1.jpg', 0);
INSERT INTO `news` VALUES (111, 5, 'Linux下浅谈crond与crontab', 'crond是Linux系统用来定期执行命令或指定程序的服务的一种服务或软件。一般情况下当我们安装完成Linux操作系统之后，默认便会启动Crond任务调用服务。Crond服务会定期（默认一分钟检查一次）检查系统中是否有要执行的任务工作。如果有，便根据其预先设定的定时任务规则自动执行该定时任务工作。这个Crond定时服务就像我们的闹钟一样。 \ncrontab是用于设置周期性被执行的指令，该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取与执行。 ', '', NULL, NULL, 0, '2017-07-08 12:08:17', 3, '已审核', 'sg4.jpg', 0);
INSERT INTO `news` VALUES (112, 6, '提高应用程序可用性的五个要点', '构建一个高可用、可伸缩的应用程序不是一件容易的事，也不会是天上掉下来的馅饼。问题总会以你从未预期的方式出现，让你精心设计的功能对所有用户都停止工作。\n\n　　这些可用性问题通常会在你最想不到的地方出现，甚至一些最严重的问题会来自于最不可能出现的地方。', '', NULL, NULL, 0, '2017-07-08 12:08:17', 2, '已审核', 'sg5.jpg', 0);
INSERT INTO `news` VALUES (117, 3, 'AI Insight：Python 为何能坐稳 AI 时代头牌语言', '谁会成为AI 和大数据时代的第一开发语言？这本已是一个不需要争论的问题。如果说三年前，Matlab、Scala、R、Java 和 Python还各有机会，局面尚且不清楚，那么三年之后，趋势已经非常明确了，特别是前两天 Facebook 开源了 PyTorch 之后，Python 作为 AI 时代头牌语言的位置基本确立，未来的悬念仅仅是谁能坐稳第二把交椅。\r\n \r\n不过声音市场上还有一些杂音。最近一个有意学习数据科学的姑娘跟我说，她的一个朋友建议她从 Java 入手，因为 Hadoop 等大数据基础设施是用 Java 写的。无独有偶，上个月 IBM developerWorks 发表的一篇个人博客（https://www.ibm.com/developerworks/community/blogs/jfp/entry/What_Language_Is_Best_For_Machine_Learning_And_Data_Science?lang=en），用职位招聘网站indeed 上的数据做了一个统计。这篇文章本身算得上是客观公正，实事求是，但传到国内来，就被一些评论者曲解了本意，说 Python 的优势地位尚未确立，鹿死谁手尚未可知，各位学习者不可盲目跟风啊，千万要多方押宝，继续撒胡椒面不要停。\r\n ', '张三1', '', '', 0, '2017-07-11 10:29:43', 4, '已审核', 'article3.jpg', 0);
INSERT INTO `news` VALUES (118, 2, '最全面的 Android 导航模式解析', '使用应用程序将两个用户屏幕连接到一起，便是一种导航。这个连接——无论它是什么——即是用户用来运送信息的载具。尽管创建一个导航很简单，但是去创造一个适当的导航并不容易。本文我们将研究一些 Android 上最常用的导航模式，解读它们是如何影响底层导航，如何正确的使用这些模式让它来符合用户的需求。', 'zhang', 'liu', '网络', 0, '2017-07-17 14:00:35', 5, '已审核', 'article1.jpg', 0);
INSERT INTO `news` VALUES (119, 6, '10个JavaScript难点', '<h3 id=\"h3_0\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; font-size: 18px; font-weight: 500; color: rgb(61, 70, 77); font-family: \'Pingfang SC\', STHeiti, \'Lantinghei SC\', \'Open Sans\', Arial, \'Hiragino Sans GB\', \'Microsoft YaHei\', \'WenQuanYi Micro Hei\', SimSun, sans-serif; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: 28px; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248);\">1. 立即执行函数</h3>\r\n<p style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; margin-bottom: 16px; color: rgb(61, 70, 77); font-family: \'Pingfang SC\', STHeiti, \'Lantinghei SC\', \'Open Sans\', Arial, \'Hiragino Sans GB\', \'Microsoft YaHei\', \'WenQuanYi Micro Hei\', SimSun, sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 28px; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248);\"><strong style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">立即执行函数</strong>，即Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：</p>\r\n<pre class=\"hljs actionscript\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; display: block; overflow-x: auto; padding: 2px; color: rgb(220, 220, 220); border-radius: 3px; line-height: 1.4; word-wrap: normal; font-size: 13px; font-family: Menlo, Monaco, Consolas, \'Courier New\', monospace; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background: rgb(63, 63, 63);\"><code class=\"lang-javascript hljs\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; display: block; overflow-x: auto; padding: 10px; color: rgb(220, 220, 220); border-radius: 4px; font-size: 13px; line-height: 1.4; word-wrap: normal; font-family: Menlo, Monaco, Consolas, \'Courier New\', monospace; background: rgb(63, 63, 63);\">(<span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\">function</span></span></span></span></span></span></span><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-params\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-params\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">(</span></span></span></span></span><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-params\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-params\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">)</span></span></span></span><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"> </span></span></span></span>{      <span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\">// 代码</span></span></span></span>      <span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\">// ...</span></span></span></span> })(); </code></pre>\r\n<p style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; margin-bottom: 16px; color: rgb(61, 70, 77); font-family: \'Pingfang SC\', STHeiti, \'Lantinghei SC\', \'Open Sans\', Arial, \'Hiragino Sans GB\', \'Microsoft YaHei\', \'WenQuanYi Micro Hei\', SimSun, sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 28px; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248);\"><strong style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">function(){&hellip;}</strong>是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。<strong style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">立即执行函数</strong>也可以理解为立即调用一个匿名函数。<strong style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">立即执行函数</strong>最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。</p>\r\n<h3 id=\"h3_1\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; font-size: 18px; font-weight: 500; color: rgb(61, 70, 77); font-family: \'Pingfang SC\', STHeiti, \'Lantinghei SC\', \'Open Sans\', Arial, \'Hiragino Sans GB\', \'Microsoft YaHei\', \'WenQuanYi Micro Hei\', SimSun, sans-serif; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: 28px; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248);\">2. 闭包</h3>\r\n<p style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; margin-bottom: 16px; color: rgb(61, 70, 77); font-family: \'Pingfang SC\', STHeiti, \'Lantinghei SC\', \'Open Sans\', Arial, \'Hiragino Sans GB\', \'Microsoft YaHei\', \'WenQuanYi Micro Hei\', SimSun, sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 28px; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248);\">对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。</p>\r\n<pre class=\"hljs javascript\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; display: block; overflow-x: auto; padding: 2px; color: rgb(220, 220, 220); border-radius: 3px; line-height: 1.4; word-wrap: normal; font-size: 13px; font-family: Menlo, Monaco, Consolas, \'Courier New\', monospace; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background: rgb(63, 63, 63);\"><code class=\"lang-javascript hljs\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; display: block; overflow-x: auto; padding: 10px; color: rgb(220, 220, 220); border-radius: 4px; font-size: 13px; line-height: 1.4; word-wrap: normal; font-family: Menlo, Monaco, Consolas, \'Courier New\', monospace; background: rgb(63, 63, 63);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\">function</span></span></span></span></span></span></span><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"> </span></span></span><span class=\"hljs-title\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(239, 239, 143);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-title\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(239, 239, 143);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-title\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(239, 239, 143);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-title\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(239, 239, 143);\">f1</span></span></span></span></span></span></span><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">(</span></span></span><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">) </span></span></span></span>{     <span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\">var</span></span></span></span> N = <span class=\"hljs-number\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(140, 208, 211);\"><span class=\"hljs-number\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(140, 208, 211);\"><span class=\"hljs-number\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(140, 208, 211);\"><span class=\"hljs-number\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(140, 208, 211);\">0</span></span></span></span>; <span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\">// N是f1函数的局部变量</span></span></span></span>      <span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\">function</span></span></span></span></span></span></span><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"> </span></span></span><span class=\"hljs-title\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(239, 239, 143);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-title\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(239, 239, 143);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-title\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(239, 239, 143);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-title\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(239, 239, 143);\">f2</span></span></span></span></span></span></span><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">(</span></span></span><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">) // </span></span></span><span class=\"hljs-title\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(239, 239, 143);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-title\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(239, 239, 143);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-title\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(239, 239, 143);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-title\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(239, 239, 143);\">f2</span></span></span></span></span></span></span><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">是</span></span></span><span class=\"hljs-title\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(239, 239, 143);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-title\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(239, 239, 143);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-title\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(239, 239, 143);\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-title\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(239, 239, 143);\">f1</span></span></span></span></span></span></span><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\"><span class=\"hljs-function\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">函数的内部函数，是闭包     </span></span></span></span>{         N += <span class=\"hljs-number\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(140, 208, 211);\"><span class=\"hljs-number\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(140, 208, 211);\"><span class=\"hljs-number\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(140, 208, 211);\"><span class=\"hljs-number\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(140, 208, 211);\">1</span></span></span></span>; <span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\">// 内部函数f2中使用了外部函数f1中的变量N</span></span></span></span>         <span class=\"hljs-built_in\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(204, 147, 147);\"><span class=\"hljs-built_in\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(204, 147, 147);\"><span class=\"hljs-built_in\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(204, 147, 147);\"><span class=\"hljs-built_in\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(204, 147, 147);\">console</span></span></span></span>.log(N);     }      <span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\">return</span></span></span></span> f2; }  <span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\"><span class=\"hljs-keyword\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(227, 206, 171);\">var</span></span></span></span> result = f1();  result(); <span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\">// 输出1</span></span></span></span> result(); <span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\">// 输出2</span></span></span></span> result(); <span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\"><span class=\"hljs-comment\" style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: rgb(127, 159, 127);\">// 输出3</span></span></span></span> </code></pre>\r\n<p style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent; margin-bottom: 16px; color: rgb(61, 70, 77); font-family: \'Pingfang SC\', STHeiti, \'Lantinghei SC\', \'Open Sans\', Arial, \'Hiragino Sans GB\', \'Microsoft YaHei\', \'WenQuanYi Micro Hei\', SimSun, sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 28px; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248);\">代码中，外部函数<strong style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">f1</strong>只执行了一次，变量<strong style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">N</strong>设为<strong style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">0</strong>，并将内部函数<strong style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">f2</strong>赋值给了变量<strong style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">result</strong>。由于外部函数<strong style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">f1</strong>已经执行完毕，其内部变量<strong style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">N</strong>应该在内存中被清除，然而事实并不是这样：我们每次调用<strong style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">result</strong>的时候，发现变量<strong style=\"box-sizing: inherit; -webkit-tap-highlight-color: transparent;\">N</strong>一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！</p>', 'liu', 'zhang', '网络', 0, '2017-07-18 13:12:52', 5, '已审核', '3.jpg', 0);
INSERT INTO `news` VALUES (120, 5, ' I/O多路复用之poll', '<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(63, 63, 63); font-family: \'microsoft yahei\'; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 35px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);\">由于poll是对select的改进，poll的功能和select的功能一样，只不过是参数稍微不同，poll的底层原理也和select差不多。<span class=\"Apple-converted-space\">&nbsp;</span><br style=\"box-sizing: border-box;\" />\r\n对多路复用select()不太熟悉的可以参考这篇博文：<a href=\"http://blog.csdn.net/fengxinlinux/article/details/75268914\" target=\"_blank\" style=\"text-decoration: none; box-sizing: border-box; color: rgb(12, 137, 207);\">I/O多路复用之select</a><span class=\"Apple-converted-space\">&nbsp;</span><br style=\"box-sizing: border-box;\" />\r\n&nbsp;</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(63, 63, 63); font-family: \'microsoft yahei\'; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 35px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);\">我们首先回忆一下 select接口 :</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(63, 63, 63); font-family: \'microsoft yahei\'; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 35px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);\">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</p>\r\n<p style=\"margin: 0px 0px 1.1em; padding: 0px; box-sizing: border-box; color: rgb(63, 63, 63); font-family: \'microsoft yahei\'; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 35px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);\">select需要我们指定文件描述符的最大值，然后取[0，nfds)这个范围内的值查看是在集合readfds,writefds或execptfds中，也就是说这个范围内存在一些不是我们感兴趣的文件描述符，cpu做了一些无用功，poll对它进行了改进</p>\r\n<p><img src=\"/news/userfiles/image/templatemo_image_04.jpg\" width=\"162\" height=\"123\" alt=\"\" /></p>', 'chenjian', 'chenjian', 'net', 0, '2017-07-18 15:59:04', 16, '已审核', '2.jpg', 0);
INSERT INTO `news` VALUES (121, 5, '谈一谈反范式设计下简单高效的冗余数据刷新思路1', '<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: rgb(62, 62, 62); font-family: -apple-system-font, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei\', sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 25.6px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);\">随着业务数据量的增长，不可避免的需要需要在数据库层面引入一些反范式的设计手段，以保证更好的数据库查询性能，但反范式设计不是银弹，解决了一些问题的同时，也会带来新的问题。</p>\r\n<p style=\"margin: 20px 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: rgb(62, 62, 62); font-family: -apple-system-font, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei\', sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 25.6px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);\">这就是冗余数据的同步与刷新问题，当一份数据存在于多个拷贝，如何简单高效的保证各份数据的同步和一致，变成了新的需要解决的难题。</p>\r\n<p style=\"margin: 20px 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: rgb(62, 62, 62); font-family: -apple-system-font, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei\', sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 25.6px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);\">本文总结笔者在这一块的经验与思考，首先会介绍我们遇到的问题及常规解决方案，然后探讨更加简单高效的方案，希望对读者有所启发~<img src=\"/news/userfiles/image/templatemo_image_04.jpg\" alt=\"\" width=\"89\" height=\"68\" /></p>', 'zheng', 'zheng', '自创', 0, '2017-07-18 16:07:47', 18, '已审核', '1.jpg', 1);
INSERT INTO `news` VALUES (125, 2, '123', '<p>213213</p>', '132', '123', '123', 0, '2018-01-04 09:59:13', 0, '已审核', '2018010409592652.jpg', 1);
INSERT INTO `news` VALUES (126, 1, '1234444444444', ' \r\n				 \r\n				', '24444444', '244444', '2444444', 0, '2018-05-09 14:07:52', 0, '未审核', '2018050902101286.', 1);
INSERT INTO `news` VALUES (127, 1, '12', '<p>123213 &nbsp;</p>', '123', '123', '123', 0, '2018-05-11 16:52:38', 0, '未审核', '2018051104523837.png', 1);

-- ----------------------------
-- Table structure for newsadmin
-- ----------------------------
DROP TABLE IF EXISTS `newsadmin`;
CREATE TABLE `newsadmin`  (
  `userName` varchar(20) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL DEFAULT '',
  `password` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `lastLogin` datetime NULL DEFAULT NULL,
  `lastLoginIp` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `type` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `isDel` int(11) NULL DEFAULT NULL,
  `adminId` int(11) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY USING BTREE (`adminId`)
) ENGINE = MyISAM AUTO_INCREMENT = 17 CHARACTER SET = gb2312 COLLATE = gb2312_chinese_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of newsadmin
-- ----------------------------
INSERT INTO `newsadmin` VALUES ('admin', '123', '2017-07-19 16:35:59', 'fe80:0:0:0:d005:5688:9cdc:9291', '1', 0, 1);
INSERT INTO `newsadmin` VALUES ('editor', 'editor', '2017-07-17 15:27:38', 'fe80:0:0:0:d005:5688:9cdc:9291', '2', 1, 2);
INSERT INTO `newsadmin` VALUES ('zhang', 'zhang', '2017-07-17 13:33:46', 'fe80:0:0:0:d005:5688:9cdc:9291', '3', 0, 3);
INSERT INTO `newsadmin` VALUES ('nolan', 'nolan', '2017-07-18 15:05:25', 'fe80:0:0:0:d005:5688:9cdc:9291', '3', 0, 4);
INSERT INTO `newsadmin` VALUES ('lei', '456', NULL, NULL, '2', 0, 5);
INSERT INTO `newsadmin` VALUES ('yu', '123', NULL, NULL, '1', 0, 6);
INSERT INTO `newsadmin` VALUES ('qing', 'qing', NULL, NULL, '2', 0, 7);
INSERT INTO `newsadmin` VALUES ('huang', 'huang', NULL, NULL, '3', 0, 8);
INSERT INTO `newsadmin` VALUES ('xu', 'xu', NULL, NULL, '2', 0, 9);
INSERT INTO `newsadmin` VALUES ('lan', 'lan', NULL, NULL, '3', 1, 10);
INSERT INTO `newsadmin` VALUES ('jiang', 'jiang', NULL, NULL, '2', 1, 11);
INSERT INTO `newsadmin` VALUES ('ying', 'ying', NULL, NULL, '3', 0, 12);
INSERT INTO `newsadmin` VALUES ('123', '123', NULL, NULL, '2', 0, 15);
INSERT INTO `newsadmin` VALUES ('dj', '123', NULL, NULL, '1', 0, 16);

-- ----------------------------
-- Table structure for newsclass
-- ----------------------------
DROP TABLE IF EXISTS `newsclass`;
CREATE TABLE `newsclass`  (
  `classId` int(11) NOT NULL AUTO_INCREMENT,
  `content` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `isDel` int(11) NULL DEFAULT NULL,
  `type` varchar(20) CHARACTER SET gb2312 COLLATE gb2312_chinese_ci NULL DEFAULT NULL,
  PRIMARY KEY USING BTREE (`classId`)
) ENGINE = MyISAM AUTO_INCREMENT = 14 CHARACTER SET = gb2312 COLLATE = gb2312_chinese_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of newsclass
-- ----------------------------
INSERT INTO `newsclass` VALUES (1, 'JavaWeb', 1, '1');
INSERT INTO `newsclass` VALUES (2, '物联网', 0, '1');
INSERT INTO `newsclass` VALUES (3, 'Android', 0, '1');
INSERT INTO `newsclass` VALUES (4, '数据库', 0, '1');
INSERT INTO `newsclass` VALUES (5, '系统网络安全', 0, '1');
INSERT INTO `newsclass` VALUES (6, 'Web前端', 0, '1');
INSERT INTO `newsclass` VALUES (10, '123', 1, '1');
INSERT INTO `newsclass` VALUES (11, 'uml建模', 1, '1');
INSERT INTO `newsclass` VALUES (12, '1233333', 1, '1');
INSERT INTO `newsclass` VALUES (13, '123', 0, '1');

-- ----------------------------
-- Table structure for newsuser
-- ----------------------------
DROP TABLE IF EXISTS `newsuser`;
CREATE TABLE `newsuser`  (
  `userName` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `sex` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `question` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `answer` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `emailAddr` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `qq` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `regTime` datetime NULL DEFAULT NULL,
  `isDel` int(11) NULL DEFAULT NULL,
  `userId` int(11) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY USING BTREE (`userId`)
) ENGINE = MyISAM AUTO_INCREMENT = 18 CHARACTER SET = gb2312 COLLATE = gb2312_chinese_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of newsuser
-- ----------------------------
INSERT INTO `newsuser` VALUES ('orange', '123456', '男', '11111', '1111', 'eee@163.com', 'eee', '2009-12-15 15:23:00', 1, 1);
INSERT INTO `newsuser` VALUES ('zhang', '123456', '男', 'r', 'r', 'r@ghdf.com', '1234', '2017-07-09 14:57:50', 0, 2);
INSERT INTO `newsuser` VALUES ('liushan', '123456', '男', 'r', 'r', 'r@ghdf.com', '1234', '2017-07-09 15:00:42', 0, 3);
INSERT INTO `newsuser` VALUES ('zheng', '123456', '男', 'r', 'r', 'r@ghdf.com', '1234', '2017-07-09 15:06:56', 0, 4);
INSERT INTO `newsuser` VALUES ('chenchen', '123456', '女', 'r', 'r', 'r@ghdf.com', '1234', '2017-07-09 15:07:42', 0, 5);
INSERT INTO `newsuser` VALUES ('liushishi', '123456', '女', 'r', 'r', 'r@t.com', '45454', '2017-07-09 15:08:33', 0, 6);
INSERT INTO `newsuser` VALUES ('杨幂', '123456', '女', 'r', 'r', 'r@ghdf.com', '1234', '2017-07-09 15:13:02', 1, 7);
INSERT INTO `newsuser` VALUES ('zhangsan', '123456', '男', 'r', 't', 't@gf.com', '43434', '2017-07-09 16:28:10', 0, 8);
INSERT INTO `newsuser` VALUES ('zhengshuang', '123456', '女', 'ere', 'erewre', 'erer@126.com', '454535435', '2017-07-18 14:49:49', 0, 9);
INSERT INTO `newsuser` VALUES ('liujing', '123456', '男', 'name', 'liujing', 'rt@126.com', '65767777', '2017-07-17 11:32:29', 0, 10);
INSERT INTO `newsuser` VALUES ('chenzhen', '123456', '男', 'nv', 'nv', 'gdghf@126.com', '6576475', '2017-07-18 14:55:43', 0, 11);
INSERT INTO `newsuser` VALUES ('ergaijr', '123456', NULL, '123456', '13', '1@qq.com', '2435246256', '2018-01-03 14:38:20', 1, 12);
INSERT INTO `newsuser` VALUES ('123456', '123456', '男', '123456', '123456', '123456@qq.com', '123456', '2018-01-04 09:57:19', 0, 14);
INSERT INTO `newsuser` VALUES ('123', '213', '男', 'qw', 'qwe', 'wqee@qq.com', '123', '2018-01-04 10:02:30', 1, 15);
INSERT INTO `newsuser` VALUES ('hh123456', '123456', NULL, '123', '123', '123@qq.com', '123456', '2018-04-15 20:32:45', 0, 16);
INSERT INTO `newsuser` VALUES ('12', '123', NULL, '123', '123', '123', '21', '2018-05-09 15:27:04', 0, 17);

-- ----------------------------
-- Table structure for note
-- ----------------------------
DROP TABLE IF EXISTS `note`;
CREATE TABLE `note`  (
  `noteId` int(11) NOT NULL AUTO_INCREMENT,
  `userName` varchar(20) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL DEFAULT '',
  `content` mediumtext CHARACTER SET gb2312 COLLATE gb2312_chinese_ci NOT NULL,
  `noteTime` datetime NULL DEFAULT NULL,
  `newsId` int(11) NULL DEFAULT NULL,
  `isDel` int(11) NULL DEFAULT NULL,
  PRIMARY KEY USING BTREE (`noteId`)
) ENGINE = MyISAM AUTO_INCREMENT = 26 CHARACTER SET = gb2312 COLLATE = gb2312_chinese_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of note
-- ----------------------------
INSERT INTO `note` VALUES (1, 'egg', '赞', '2017-07-08 18:21:34', 111, 1);
INSERT INTO `note` VALUES (2, 'egg', 'ghhfg', '2017-07-09 10:24:20', 110, 0);
INSERT INTO `note` VALUES (3, 'egg', '呵呵', '2017-07-09 11:15:53', 111, 1);
INSERT INTO `note` VALUES (4, 'egg', '呵呵', '2017-07-09 11:21:44', 111, 1);
INSERT INTO `note` VALUES (5, 'egg', '呵呵', '2017-07-09 11:21:50', 111, 0);
INSERT INTO `note` VALUES (6, 'egg', '呵呵', '2017-07-09 11:22:55', 111, 0);
INSERT INTO `note` VALUES (7, 'egg', '我是哥哥', '2017-07-09 11:24:39', 111, 0);
INSERT INTO `note` VALUES (8, 'egg', '哥哥', '2017-07-09 11:25:44', 111, 0);
INSERT INTO `note` VALUES (9, 'egg', '好好', '2017-07-09 11:27:32', 111, 1);
INSERT INTO `note` VALUES (10, 'egg', '复古风格', '2017-07-09 11:51:12', 111, 1);
INSERT INTO `note` VALUES (11, 'egg', '我没有', '2017-07-09 11:51:38', 109, 0);
INSERT INTO `note` VALUES (12, 'egg', '复古风格', '2017-07-09 11:51:45', 109, 0);
INSERT INTO `note` VALUES (13, 'egg', '好几个', '2017-07-09 11:58:25', 68, 0);
INSERT INTO `note` VALUES (14, 'egg', 'vbvbvb', '2017-07-09 16:27:10', 107, 0);
INSERT INTO `note` VALUES (15, 'egg', '好几个', '2017-07-09 11:58:25', 119, 0);
INSERT INTO `note` VALUES (16, 'egg', '复古风格', '2017-07-09 11:58:25', 119, 0);
INSERT INTO `note` VALUES (17, 'egg', '我是哥哥', '2017-07-09 11:58:25', 119, 0);
INSERT INTO `note` VALUES (18, 'egg', '呵呵', '2017-07-09 11:58:25', 119, 0);
INSERT INTO `note` VALUES (19, 'orange', '11', '2017-12-31 14:25:04', 119, 0);
INSERT INTO `note` VALUES (20, 'orange', '', '2018-01-03 14:47:38', 75, 0);
INSERT INTO `note` VALUES (21, 'orange', '', '2018-01-04 00:19:45', 121, 0);
INSERT INTO `note` VALUES (22, 'orange', '124', '2018-01-04 00:19:51', 121, 0);
INSERT INTO `note` VALUES (23, 'orange', '1234', '2018-01-04 09:15:14', 75, 0);
INSERT INTO `note` VALUES (24, 'orange', '123', '2018-01-04 09:56:20', 75, 0);
INSERT INTO `note` VALUES (25, 'zhang', '123', '2018-05-11 16:51:40', 75, 0);

SET FOREIGN_KEY_CHECKS = 1;
